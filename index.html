<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <title>Browsynth</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #2a2a2a;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
        }

        #recorder-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            background-color: #333;
            padding: 10px;
            border-radius: 5px;
        }

        .control-button {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background-color: #4a4a4a;
            color: #00ff9d;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .control-button:hover {
            background-color: #5a5a5a;
        }

        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-button:active {
            transform: scale(0.95);
        }

        #startButton {
            font-size: 24px;
            padding: 15px 30px;
            background-color: #00ff9d;
            color: #1e1e1e;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #startButton:hover {
            background-color: #00cc7d;
        }

        #synth-container {
            background-color: #2a2a2a;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #00ff9d;
            margin-bottom: 20px;
        }

        #controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            background-color: #333;
            border-radius: 5px;
            padding: 15px;
        }

        .control-group h2 {
            font-size: 18px;
            margin-top: 0;
            margin-bottom: 15px;
            color: #00ff9d;
        }

        .control {
            margin-bottom: 20px;
            text-align: center;
        }

        .control label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            text-transform: uppercase;
        }

        .circular-control {
            width: 80px;
            height: 80px;
            margin: 0 auto;
            background-color: #4a4a4a;
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            touch-action: none;
        }

        .circular-control::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70px;
            height: 70px;
            background-color: #2a2a2a;
            border-radius: 50%;
        }

        .circular-control::after {
            content: '';
            position: absolute;
            top: 10%;
            left: 50%;
            width: 4px;
            height: 40%;
            background-color: #00ff9d;
            transform-origin: bottom;
            transform: translateX(-50%) rotate(var(--rotation, 0deg));
        }

        .circular-control input[type="range"] {
            display: none;
        }

        select {
            width: 100%;
            padding: 5px;
            background-color: #4a4a4a;
            color: #e0e0e0;
            border: none;
            border-radius: 5px;
        }

        #piano {
            display: flex;
            background-color: #333;
            padding: 10px;
            border-radius: 10px;
            overflow-x: auto;
            margin-bottom: 20px;
        }

        .key {
            width: 30px;
            height: 120px;
            background-color: white;
            border: 1px solid #000;
            margin: 0 1px;
            cursor: pointer;
        }

        .key.black {
            width: 20px;
            height: 80px;
            background-color: black;
            margin: 0 -10px;
            z-index: 1;
            position: relative;
        }

        .key.active {
            background-color: #00ff9d;
        }

        #visualizer {
            width: 100%;
            height: 100px;
            border: 1px solid #4a4a4a;
            border-radius: 5px;
        }

        #footer {
            text-align: center;
            margin-top: 20px;
            font-size: 14px;
            color: #00ff9d;
        }

        #footer a {
            color: #00ff9d;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        #footer a:hover {
            color: #00bfff;
            /* Crystal blue color */
            text-shadow: 0 0 5px #00bfff, 0 0 10px #00bfff;
            /* Glowing effect */
        }
    </style>
</head>

<body>
    <div id="startModal" class="modal">
        <div class="modal-content">
            <h2>Welcome to Browsynth</h2>
            <p>Click the button below to start the synthesizer.</p>
            <p>Use your keyboard to play notes.</p>
            <p>Currently not supported on mobile devices.</p>
            <button id="startButton">Start Synth</button>
        </div>
    </div>
    <div id="synth-container">
        <h1>Browsynth</h1>
        <div id="piano"></div>
        <canvas id="visualizer"></canvas>
        <div id="recorder-controls">
            <button id="recordButton" class="control-button" title="Record">
                <i class="fas fa-microphone"></i>
            </button>
            <button id="stopButton" class="control-button" disabled title="Stop">
                <i class="fas fa-stop"></i>
            </button>
            <button id="playButton" class="control-button" disabled title="Play">
                <i class="fas fa-play"></i>
            </button>
            <button id="saveButton" class="control-button" disabled title="Save">
                <i class="fas fa-save"></i>
            </button>
            <button id="exportWavButton" class="control-button" disabled title="Export WAV">
                <i class="fas fa-file-export"></i>
            </button>
            <button id="loadButton" class="control-button" title="Load">
                <i class="fas fa-folder-open"></i>
            </button>
        </div>
        <div id="controls">
            <div class="control-group">
                <h2>Oscillator</h2>
                <div class="control">
                    <label for="waveform">Waveform</label>
                    <select id="waveform">
                        <option value="sine">Sine</option>
                        <option value="square">Square</option>
                        <option value="sawtooth">Sawtooth</option>
                        <option value="triangle">Triangle</option>
                    </select>
                </div>
                <div class="control">
                    <label for="unison">Unison</label>
                    <div class="circular-control">
                        <input type="range" id="unison" min="1" max="8" step="1" value="1">
                    </div>
                </div>
                <div class="control">
                    <label for="detune">Detune</label>
                    <div class="circular-control">
                        <input type="range" id="detune" min="0" max="100" step="1" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="fmAmount">FM Amount</label>
                    <div class="circular-control">
                        <input type="range" id="fmAmount" min="0" max="1000" step="1" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="fmToggle">FM On/Off</label>
                    <input type="checkbox" id="fmToggle">
                </div>
            </div>
            <div class="control-group">
                <h2>Filter</h2>
                <div class="control">
                    <label for="filterToggle">Filter On/Off</label>
                    <input type="checkbox" id="filterToggle" checked>
                </div>
                <div class="control">
                    <label for="filterType">Filter Type</label>
                    <select id="filterType">
                        <option value="lowpass">Lowpass</option>
                        <option value="highpass">Highpass</option>
                        <option value="bandpass">Bandpass</option>
                    </select>
                </div>
                <div class="control">
                    <label for="filterCutoff">Cutoff</label>
                    <div class="circular-control">
                        <input type="range" id="filterCutoff" min="20" max="20000" step="1" value="20000">
                    </div>
                </div>
                <div class="control">
                    <label for="filterResonance">Resonance</label>
                    <div class="circular-control">
                        <input type="range" id="filterResonance" min="0" max="20" step="0.1" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="filterEnvAmount">Env Amount</label>
                    <div class="circular-control">
                        <input type="range" id="filterEnvAmount" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Envelope</h2>
                <div class="control">
                    <label for="attack">Attack</label>
                    <div class="circular-control">
                        <input type="range" id="attack" min="0" max="2" step="0.01" value="0.05">
                    </div>
                </div>
                <div class="control">
                    <label for="decay">Decay</label>
                    <div class="circular-control">
                        <input type="range" id="decay" min="0" max="2" step="0.01" value="0.1">
                    </div>
                </div>
                <div class="control">
                    <label for="sustain">Sustain</label>
                    <div class="circular-control">
                        <input type="range" id="sustain" min="0" max="1" step="0.01" value="0.5">
                    </div>
                </div>
                <div class="control">
                    <label for="release">Release</label>
                    <div class="circular-control">
                        <input type="range" id="release" min="0" max="5" step="0.01" value="0.5">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>LFO</h2>
                <div class="control">
                    <label for="lfoToggle">LFO On/Off</label>
                    <input type="checkbox" id="lfoToggle">
                </div>
                <div class="control">
                    <label for="lfoRate">Rate</label>
                    <div class="circular-control">
                        <input type="range" id="lfoRate" min="0" max="20" step="0.1" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="lfoAmount">Amount</label>
                    <div class="circular-control">
                        <input type="range" id="lfoAmount" min="0" max="1000" step="1" value="50">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Noise</h2>
                <div class="control">
                    <label for="noiseToggle">Noise On/Off</label>
                    <input type="checkbox" id="noiseToggle">
                </div>
                <div class="control">
                    <label for="noiseAmount">Amount</label>
                    <div class="circular-control">
                        <input type="range" id="noiseAmount" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Arpeggiator</h2>
                <div class="control">
                    <label for="arpToggle">Arp On/Off</label>
                    <input type="checkbox" id="arpToggle">
                </div>
                <div class="control">
                    <label for="arpClock">Clock</label>
                    <select id="arpClock">
                        <option value="1">1/1</option>
                        <option value="2">1/2</option>
                        <option value="4">1/4</option>
                        <option value="8">1/8</option>
                        <option value="16" selected>1/16</option>
                        <option value="32">1/32</option>
                        <option value="64">1/64</option>
                    </select>
                </div>
                <div class="control">
                    <label for="arpPattern">Pattern</label>
                    <select id="arpPattern">
                        <option value="up">Up</option>
                        <option value="down">Down</option>
                        <option value="upDown">Up-Down</option>
                        <option value="random">Random</option>
                    </select>
                </div>
                <div class="control">
                    <label for="arpSpeed">Speed</label>
                    <div class="circular-control">
                        <input type="range" id="arpSpeed" min="1" max="8" step="1" value="4">
                    </div>
                </div>
            </div>
        </div>
        <p id="footer">we like <a href="https://hypertrance.eu/" target="_blank"
                rel="noopener noreferrer">hypertrance</a> ❤️</p>
    </div>
    <script>
        let audioContext;
        let masterGainNode;
        let compressor;
        let analyser;

        // Synth configuration object
        const SynthConfig = {
            waveforms: ['sine', 'square', 'sawtooth', 'triangle'],
            filterTypes: ['lowpass', 'highpass', 'bandpass'],
            notes: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
            whiteNotes: ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
            blackNotes: ['C#', 'D#', 'F#', 'G#', 'A#'],
            keyboardMap: {
                'q': 'C4', 'w': 'D4', 'e': 'E4', 'r': 'F4', 't': 'G4', 'y': 'A4', 'u': 'B4',
                'ı': 'C5', 'o': 'D5', 'p': 'E5', 'ğ': 'F5', 'ü': 'G5',
                'a': 'C#4', 's': 'D#4', 'f': 'F#4', 'g': 'G#4', 'h': 'A#4',
                'j': 'C#5', 'k': 'D#5', 'l': 'F#5', 'ş': 'G#5', 'i': 'A#5',
                'z': 'C3', 'x': 'D3', 'c': 'E3', 'v': 'F3', 'b': 'G3', 'n': 'A3', 'm': 'B3',
                'ö': 'C4', 'ç': 'D4', '.': 'E4'
            },
            maxPolyphony: 8,
        };

        // Synth state
        const SynthState = {
            activeVoices: {},
            activeNotes: new Set(),
            controls: {},
            fmEnabled: false,
            lfoEnabled: false,
            noiseEnabled: false,
            arpeggiator: {
                isOn: false,
                pattern: 'up',
                speed: 4, // Default speed (middle of the range 1-8)
                notes: [],
                currentIndex: 0,
                intervalId: null
            },
            filterEnabled: true,
            filterSettings: {
                type: 'lowpass',
                frequency: 1000,
                Q: 0
            },
        };

        // Utility functions
        const Util = {
            noteToFreq(note) {
                if (!note) {
                    console.error('Invalid note:', note);
                    return 0;
                }

                let [noteName, octave] = note.match(/([A-G]#?)(\d+)/).slice(1);
                octave = parseInt(octave);

                const noteIndex = SynthConfig.notes.indexOf(noteName);
                if (noteIndex === -1) {
                    console.error('Invalid note name:', noteName);
                    return 0;
                }

                return 440 * Math.pow(2, (noteIndex - 9) / 12 + (octave - 4));
            },

            createNoiseBuffer() {
                if (!audioContext) return null;
                const bufferSize = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                return buffer;
            }
        };

        // Synth voice creation and management
        const Voice = {
            create(note) {
                if (!audioContext) return null;
                const frequency = Util.noteToFreq(note);
                const now = audioContext.currentTime;

                const oscillators = [];
                const unisonCount = parseInt(SynthState.controls.unison.value) || 1;
                const detune = parseFloat(SynthState.controls.detune.value) || 0;

                for (let i = 0; i < unisonCount; i++) {
                    const osc = audioContext.createOscillator();
                    osc.type = SynthState.controls.waveform.value;
                    osc.frequency.setValueAtTime(frequency, now);
                    const detuneAmount = unisonCount > 1 ? (i / (unisonCount - 1) - 0.5) * detune : 0;
                    osc.detune.setValueAtTime(detuneAmount, now);
                    oscillators.push(osc);
                }

                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0, now);

                const filter = audioContext.createBiquadFilter();
                filter.type = SynthState.filterSettings.type;
                filter.frequency.setValueAtTime(SynthState.filterSettings.frequency, now);
                filter.Q.setValueAtTime(SynthState.filterSettings.Q, now);

                // Connect nodes based on filter state
                if (SynthState.filterEnabled) {
                    oscillators.forEach(osc => osc.connect(filter));
                    filter.connect(gainNode);
                } else {
                    oscillators.forEach(osc => osc.connect(gainNode));
                }

                const fmOsc = audioContext.createOscillator();
                fmOsc.frequency.setValueAtTime(frequency * 2, now);
                const fmGain = audioContext.createGain();
                fmGain.gain.setValueAtTime(0, now);

                const noiseOsc = audioContext.createBufferSource();
                noiseOsc.buffer = Util.createNoiseBuffer();
                noiseOsc.loop = true;
                const noiseGain = audioContext.createGain();
                noiseGain.gain.setValueAtTime(0, now);

                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.setValueAtTime(parseFloat(SynthState.controls.lfoRate.value), now);
                lfoGain.gain.setValueAtTime(parseFloat(SynthState.controls.lfoAmount.value), now);

                // Connect LFO
                if (SynthState.lfoEnabled) {
                    lfo.connect(lfoGain);
                    lfoGain.connect(filter.frequency); // Connect to filter frequency
                }

                // Connect nodes
                if (SynthState.filterEnabled) {
                    oscillators.forEach(osc => osc.connect(filter));
                    filter.connect(gainNode);
                } else {
                    oscillators.forEach(osc => osc.connect(gainNode));
                }

                if (SynthState.noiseEnabled) {
                    noiseOsc.connect(noiseGain);
                    noiseGain.connect(SynthState.filterEnabled ? filter : gainNode);
                }

                if (SynthState.lfoEnabled) {
                    lfo.connect(lfoGain);
                    lfoGain.connect(filter.frequency);
                }

                gainNode.connect(compressor);

                // Start oscillators
                oscillators.forEach(osc => osc.start(now));
                fmOsc.start(now);
                noiseOsc.start(now);
                lfo.start(now);

                const updateVoice = () => {
                    const now = audioContext.currentTime;

                    // Update filter
                    if (SynthState.filterEnabled) {
                        filter.type = SynthState.filterSettings.type;
                        filter.frequency.cancelScheduledValues(now);
                        filter.frequency.setValueAtTime(SynthState.filterSettings.frequency, now);
                        filter.Q.cancelScheduledValues(now);
                        filter.Q.setValueAtTime(SynthState.filterSettings.Q, now);

                        oscillators.forEach(osc => {
                            osc.disconnect();
                            osc.connect(filter);
                        });
                        filter.disconnect();
                        filter.connect(gainNode);
                    } else {
                        oscillators.forEach(osc => {
                            osc.disconnect();
                            osc.connect(gainNode);
                        });
                    }

                    // Update oscillators, unison, and detune
                    const newUnisonCount = parseInt(SynthState.controls.unison.value) || 1;
                    const newDetune = parseFloat(SynthState.controls.detune.value) || 0;

                    // Adjust the number of oscillators if unison has changed
                    while (oscillators.length < newUnisonCount) {
                        const newOsc = audioContext.createOscillator();
                        newOsc.type = SynthState.controls.waveform.value;
                        newOsc.frequency.setValueAtTime(frequency, now);
                        newOsc.start(now);
                        oscillators.push(newOsc);
                    }
                    while (oscillators.length > newUnisonCount) {
                        const oscToRemove = oscillators.pop();
                        oscToRemove.stop(now);
                        oscToRemove.disconnect();
                    }

                    // Update each oscillator
                    oscillators.forEach((osc, i) => {
                        osc.type = SynthState.controls.waveform.value;
                        const detuneAmount = newUnisonCount > 1 ? (i / (newUnisonCount - 1) - 0.5) * newDetune : 0;
                        osc.detune.setValueAtTime(detuneAmount, now);

                        // Reconnect oscillator if filter state has changed
                        osc.disconnect();
                        if (SynthState.filterEnabled) {
                            osc.connect(filter);
                        } else {
                            osc.connect(gainNode);
                        }
                    });

                    // Update FM
                    if (SynthState.fmEnabled) {
                        fmGain.gain.setValueAtTime(parseFloat(SynthState.controls.fmAmount.value), now);
                    } else {
                        fmGain.gain.setValueAtTime(0, now);
                    }

                    // Update Noise
                    if (SynthState.noiseEnabled) {
                        noiseGain.gain.setValueAtTime(parseFloat(SynthState.controls.noiseAmount.value), now);
                        noiseOsc.connect(noiseGain);
                        noiseGain.connect(SynthState.filterEnabled ? filter : gainNode);
                    } else {
                        noiseGain.gain.setValueAtTime(0, now);
                        noiseOsc.disconnect();
                        noiseGain.disconnect();
                    }

                    // Update LFO
                    if (SynthState.lfoEnabled) {
                        lfo.frequency.setValueAtTime(parseFloat(SynthState.controls.lfoRate.value), now);
                        lfoGain.gain.setValueAtTime(parseFloat(SynthState.controls.lfoAmount.value), now);
                        lfo.connect(lfoGain);
                        lfoGain.connect(filter.frequency);
                    } else {
                        lfo.disconnect();
                        lfoGain.disconnect();
                    }
                };

                return { oscillators, gainNode, filter, fmOsc, fmGain, noiseOsc, noiseGain, lfo, lfoGain, updateVoice };
            },

            play(note, isArpeggiator = false) {
                if (SynthState.arpeggiator.isOn && !isArpeggiator) {
                    Arpeggiator.addNote(note);
                    return;
                }
                if (SynthState.activeVoices[note]) return;

                if (Object.keys(SynthState.activeVoices).length >= SynthConfig.maxPolyphony) {
                    const oldestNote = Object.keys(SynthState.activeVoices)[0];
                    this.release(oldestNote);
                }

                const voice = this.create(note);
                SynthState.activeVoices[note] = voice;
                SynthState.activeNotes.add(note);
                Synth.recordNoteEvent(note, true);

                const now = audioContext.currentTime;
                const attackTime = parseFloat(SynthState.controls.attack.value);
                const decayTime = parseFloat(SynthState.controls.decay.value);
                const sustainLevel = parseFloat(SynthState.controls.sustain.value);

                // Adjust the peak level based on the number of active voices
                const peakLevel = 0.5 / Math.max(1, Math.sqrt(Object.keys(SynthState.activeVoices).length));
                const sustainedLevel = sustainLevel * peakLevel;

                voice.gainNode.gain.linearRampToValueAtTime(peakLevel, now + attackTime);
                voice.gainNode.gain.linearRampToValueAtTime(sustainedLevel, now + attackTime + decayTime);

                // Filter envelope
                const filterEnvAmount = parseFloat(SynthState.controls.filterEnvAmount.value);
                const filterStartFreq = SynthState.filterSettings.frequency;
                const filterPeakFreq = Math.min(filterStartFreq * (1 + filterEnvAmount * 10), audioContext.sampleRate / 2);

                // Apply noise envelope
                if (SynthState.noiseEnabled) {
                    const noiseAmount = parseFloat(SynthState.controls.noiseAmount.value);
                    voice.noiseGain.gain.cancelScheduledValues(now);
                    voice.noiseGain.gain.setValueAtTime(0, now);
                    voice.noiseGain.gain.linearRampToValueAtTime(noiseAmount, now + attackTime);
                    voice.noiseGain.gain.linearRampToValueAtTime(noiseAmount * sustainLevel, now + attackTime + decayTime);
                }

                // Apply LFO envelope
                if (SynthState.lfoEnabled) {
                    const lfoAmount = parseFloat(SynthState.controls.lfoAmount.value);
                    voice.lfoGain.gain.cancelScheduledValues(now);
                    voice.lfoGain.gain.setValueAtTime(0, now);
                    voice.lfoGain.gain.linearRampToValueAtTime(lfoAmount, now + attackTime);
                }

                if (SynthState.filterEnabled) {
                    voice.filter.frequency.cancelScheduledValues(now);
                    voice.filter.frequency.setValueAtTime(filterStartFreq, now);
                    voice.filter.frequency.linearRampToValueAtTime(filterPeakFreq, now + attackTime);
                    voice.filter.frequency.linearRampToValueAtTime(filterStartFreq, now + attackTime + decayTime);
                }

                const keyElement = document.querySelector(`.key[data-note="${note}"]`);
                if (keyElement) keyElement.classList.add('active');
            },

            release(note, isArpeggiator = false) {
                if (SynthState.arpeggiator.isOn && !isArpeggiator) {
                    Arpeggiator.removeNote(note);
                    return;
                }

                const voice = SynthState.activeVoices[note];
                Synth.recordNoteEvent(note, false);
                if (!voice) return;

                const now = audioContext.currentTime;
                const releaseTime = parseFloat(SynthState.controls.release.value);

                voice.gainNode.gain.cancelScheduledValues(now);
                voice.gainNode.gain.setValueAtTime(voice.gainNode.gain.value, now);
                voice.gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);

                // Apply noise release
                if (SynthState.noiseEnabled) {
                    voice.noiseGain.gain.cancelScheduledValues(now);
                    voice.noiseGain.gain.setValueAtTime(voice.noiseGain.gain.value, now);
                    voice.noiseGain.gain.linearRampToValueAtTime(0, now + releaseTime);
                }

                // Apply LFO release
                if (SynthState.lfoEnabled) {
                    voice.lfoGain.gain.cancelScheduledValues(now);
                    voice.lfoGain.gain.setValueAtTime(voice.lfoGain.gain.value, now);
                    voice.lfoGain.gain.linearRampToValueAtTime(0, now + releaseTime);
                }

                setTimeout(() => {
                    voice.oscillators.forEach(osc => {
                        osc.stop();
                        osc.disconnect();
                    });
                    voice.gainNode.disconnect();
                    voice.filter.disconnect();
                    voice.fmOsc.stop();
                    voice.fmOsc.disconnect();
                    voice.fmGain.disconnect();
                    voice.noiseOsc.stop();
                    voice.noiseOsc.disconnect();
                    voice.noiseGain.disconnect();
                    voice.lfo.stop();
                    voice.lfo.disconnect();
                    voice.lfoGain.disconnect();
                }, releaseTime * 1000);

                delete SynthState.activeVoices[note];
                SynthState.activeNotes.delete(note);

                const keyElement = document.querySelector(`.key[data-note="${note}"]`);
                if (keyElement) keyElement.classList.remove('active');
            },

            stopAllNotes: function (isArpeggiator = false) {
                if (SynthState.arpeggiator.isOn && !isArpeggiator) {
                    Arpeggiator.stop();
                    return;
                }
                SynthState.activeNotes.forEach(note => {
                    if (SynthState.activeVoices[note]) {
                        this.release(note, true);
                    }
                });
                SynthState.activeNotes.clear();
                const keys = document.querySelectorAll('.key.active');
                keys.forEach(key => key.classList.remove('active'));
            }
        };
        // Bind the method to the Voice object
        Voice.stopAllNotes = Voice.stopAllNotes.bind(Voice);
        // Arpeggiator functionality
        const Arpeggiator = {
            step: 0,
            direction: 1,

            start() {
                if (SynthState.arpeggiator.notes.length === 0) return;
                this.stop();
                this.step = 0;
                this.direction = 1;
                this.playCurrentNote();
                const speed = this.calculateSpeed();
                SynthState.arpeggiator.intervalId = setInterval(() => this.playNextNote(), speed);
            },

            stop() {
                if (SynthState.arpeggiator.intervalId) {
                    clearInterval(SynthState.arpeggiator.intervalId);
                    SynthState.arpeggiator.intervalId = null;
                }
                Voice.stopAllNotes(true);
            },

            calculateSpeed() {
                const clockValue = parseInt(SynthState.controls.arpClock.value);
                const speedValue = parseInt(SynthState.controls.arpSpeed.value);
                // Base speed of 500ms (120 BPM) divided by clock division and multiplied by speed factor
                return (500 / clockValue) * (9 - speedValue);
            },

            updateSpeed() {
                if (SynthState.arpeggiator.isOn && SynthState.arpeggiator.notes.length > 0) {
                    this.stop();
                    this.start();
                }
            },

            addNote(note) {
                if (!SynthState.arpeggiator.notes.includes(note)) {
                    SynthState.arpeggiator.notes.push(note);
                }
                if (SynthState.arpeggiator.isOn && SynthState.arpeggiator.notes.length === 1) {
                    this.start();
                }
            },

            removeNote(note) {
                const index = SynthState.arpeggiator.notes.indexOf(note);
                if (index > -1) {
                    SynthState.arpeggiator.notes.splice(index, 1);
                }
                if (SynthState.arpeggiator.notes.length === 0) {
                    this.stop();
                }
            },

            playNextNote() {
                if (SynthState.arpeggiator.notes.length === 0) {
                    this.stop();
                    return;
                }
                this.step = this.getNextStep();
                this.playCurrentNote();
            },

            playCurrentNote() {
                if (SynthState.arpeggiator.notes.length === 0) return;
                const note = SynthState.arpeggiator.notes[this.step];
                Voice.stopAllNotes(true);
                Voice.play(note, true);
            },

            getNextStep() {
                const { pattern, notes } = SynthState.arpeggiator;
                const notesCount = notes.length;
                switch (pattern) {
                    case 'up':
                        return (this.step + 1) % notesCount;
                    case 'down':
                        return (this.step - 1 + notesCount) % notesCount;
                    case 'upDown':
                        if (this.step === 0) this.direction = 1;
                        else if (this.step === notesCount - 1) this.direction = -1;
                        return (this.step + this.direction + notesCount) % notesCount;
                    case 'random':
                        return Math.floor(Math.random() * notesCount);
                    default:
                        return (this.step + 1) % notesCount;
                }
            },
        };
        // UI related functions
        const UI = {
            createPiano() {
                const piano = document.getElementById('piano');
                piano.innerHTML = '';
                for (let octave = 1; octave < 7; octave++) {
                    SynthConfig.whiteNotes.forEach(note => {
                        const key = document.createElement('div');
                        key.className = 'key';
                        key.dataset.note = note + octave;
                        piano.appendChild(key);
                    });
                }

                const whiteKeys = piano.querySelectorAll('.key');
                let blackKeyIndex = 0;
                whiteKeys.forEach((whiteKey, index) => {
                    if (index % 7 !== 2 && index % 7 !== 6) {
                        const blackKey = document.createElement('div');
                        blackKey.className = 'key black';
                        blackKey.dataset.note = SynthConfig.blackNotes[blackKeyIndex % 5] + (Math.floor(index / 7) + 1);
                        whiteKey.parentNode.insertBefore(blackKey, whiteKey.nextSibling);
                        blackKeyIndex++;
                    }
                });
            },

            updateVisualizer() {
                if (!analyser) return;
                const visualizer = document.getElementById('visualizer');
                visualizer.width = visualizer.offsetWidth;
                visualizer.height = visualizer.offsetHeight;
                const ctx = visualizer.getContext('2d');
                const width = visualizer.width;
                const height = visualizer.height;

                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                ctx.lineWidth = 2;
                ctx.strokeStyle = '#00ff9d';

                function draw() {
                    requestAnimationFrame(draw);
                    analyser.getByteTimeDomainData(dataArray);

                    ctx.fillStyle = 'rgba(26, 26, 26, 0.2)';
                    ctx.fillRect(0, 0, width, height);

                    ctx.beginPath();
                    const sliceWidth = width * 1.0 / bufferLength;
                    let x = 0;

                    for (let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = v * height / 2;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }

                        x += sliceWidth;
                    }

                    ctx.lineTo(width, height / 2);
                    ctx.stroke();
                }

                draw();
            },

            updateCircularControls() {
                document.querySelectorAll('.circular-control input[type="range"]').forEach(input => {
                    const value = parseFloat(input.value);
                    const min = parseFloat(input.min);
                    const max = parseFloat(input.max);
                    const normalizedValue = (value - min) / (max - min);
                    const rotation = normalizedValue * 270 - 135; // Map 0-1 to -135deg to 135deg
                    input.parentNode.style.setProperty('--rotation', `${rotation}deg`);
                });
            },

            handleCircularControlInteraction(event) {
                const control = event.currentTarget;
                const input = control.querySelector('input[type="range"]');
                let startY, startValue;

                function handleStart(e) {
                    startY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                    startValue = parseFloat(input.value);
                    document.addEventListener('mousemove', handleMove);
                    document.addEventListener('touchmove', handleMove, { passive: false });
                    document.addEventListener('mouseup', handleEnd);
                    document.addEventListener('touchend', handleEnd);
                }

                function handleMove(e) {
                    const currentY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                    const deltaY = startY - currentY;
                    const range = input.max - input.min;
                    const valueChange = (deltaY / 100) * range;
                    let newValue = Math.max(input.min, Math.min(input.max, startValue + valueChange));

                    input.value = newValue;
                    Synth.updateParams();
                    input.dispatchEvent(new Event('input'));
                    e.preventDefault();
                }

                function handleEnd() {
                    document.removeEventListener('mousemove', handleMove);
                    document.removeEventListener('touchmove', handleMove);
                    document.removeEventListener('mouseup', handleEnd);
                    document.removeEventListener('touchend', handleEnd);
                }

                if (event.type === 'mousedown') {
                    handleStart(event);
                } else if (event.type === 'touchstart') {
                    handleStart(event);
                }
            },
            initializeEventListeners() {
                const keys = document.querySelectorAll('.key');
                let isMouseDown = false;
                let lastPlayedNote = null;

                keys.forEach(key => {
                    key.addEventListener('mousedown', (e) => {
                        isMouseDown = true;
                        const note = e.target.dataset.note;
                        Voice.play(note);
                        lastPlayedNote = note;
                    });

                    key.addEventListener('mouseenter', (e) => {
                        if (isMouseDown) {
                            const note = e.target.dataset.note;
                            if (note !== lastPlayedNote) {
                                Voice.release(lastPlayedNote);
                                Voice.play(note);
                                lastPlayedNote = note;
                            }
                        }
                    });

                    key.addEventListener('mouseleave', (e) => {
                        if (isMouseDown) {
                            const note = e.target.dataset.note;
                            Voice.release(note);
                        }
                    });
                });

                document.addEventListener('mouseup', () => {
                    if (isMouseDown) {
                        Voice.release(lastPlayedNote);
                        isMouseDown = false;
                        lastPlayedNote = null;
                    }
                });

                document.getElementById('piano').addEventListener('selectstart', (e) => e.preventDefault());

                // Control event listeners
                Object.entries(SynthState.controls).forEach(([key, control]) => {
                    if (control.type === 'checkbox') {
                        control.addEventListener('change', () => Synth.updateParams(key));
                    } else {
                        control.addEventListener('input', () => Synth.updateParams(key));
                    }
                });

                // Arpeggiator controls
                SynthState.controls.arpToggle.addEventListener('change', (e) => {
                    SynthState.arpeggiator.isOn = e.target.checked;
                    if (SynthState.arpeggiator.isOn) {
                        if (SynthState.arpeggiator.notes.length > 0) {
                            Arpeggiator.start();
                        }
                    } else {
                        Arpeggiator.stop();
                    }
                });

                SynthState.controls.filterToggle.addEventListener('change', () => Synth.updateParams('filterToggle'));
                SynthState.controls.arpSpeed.addEventListener('input', Arpeggiator.updateSpeed);
                SynthState.controls.arpClock.addEventListener('change', Arpeggiator.updateSpeed);
                SynthState.controls.arpPattern.addEventListener('change', Arpeggiator.updateSpeed);
                SynthState.controls.noiseToggle.addEventListener('change', () => Synth.updateParams('noiseToggle'));
                SynthState.controls.noiseAmount.addEventListener('input', () => Synth.updateParams('noiseAmount'));
                SynthState.controls.lfoToggle.addEventListener('change', () => Synth.updateParams('lfoToggle'));
                SynthState.controls.lfoRate.addEventListener('input', () => Synth.updateParams('lfoRate'));
                SynthState.controls.lfoAmount.addEventListener('input', () => Synth.updateParams('lfoAmount'));
                SynthState.controls.unison.addEventListener('input', () => Synth.updateParams('unison'));
                SynthState.controls.detune.addEventListener('input', () => Synth.updateParams('detune'));
                SynthState.controls.waveform.addEventListener('change', () => Synth.updateParams('waveform'));

                // Keyboard controls
                document.addEventListener('keydown', (event) => {
                    const note = SynthConfig.keyboardMap[event.key.toLowerCase()];
                    if (note && !event.repeat) {
                        Voice.play(note);
                    }
                });

                document.addEventListener('keyup', (event) => {
                    const note = SynthConfig.keyboardMap[event.key.toLowerCase()];
                    if (note) {
                        Voice.release(note);
                    }
                });

                window.addEventListener('blur', () => Voice.stopAllNotes());
                window.addEventListener('resize', this.updateVisualizer);

                document.querySelectorAll('.circular-control').forEach(control => {
                    control.addEventListener('mousedown', this.handleCircularControlInteraction);
                    control.addEventListener('touchstart', this.handleCircularControlInteraction, { passive: false });
                });
            }
        };

        // Main Synth object
        const Synth = {
            recorder: null,
            recordedChunks: [],
            recordedNotes: [],
            recordingStartTime: 0,
            audioContext: null,
            compressor: null,
            playbackAudio: null,
            playbackSource: null,

            initialize() {
                const startButton = document.getElementById('startButton');
                const startModal = document.getElementById('startModal');
                const exportWavButton = document.getElementById('exportWavButton');
                exportWavButton.addEventListener('click', () => this.exportWav());

                startButton.addEventListener('click', () => {
                    this.initAudioContext();
                    startModal.style.display = 'none';
                    this.start();
                });

                const recordButton = document.getElementById('recordButton');
                const stopButton = document.getElementById('stopButton');
                const saveButton = document.getElementById('saveButton');
                const loadButton = document.getElementById('loadButton');
                const playButton = document.getElementById('playButton');

                recordButton.addEventListener('click', () => this.startRecording());
                stopButton.addEventListener('click', () => this.stopRecording());
                saveButton.addEventListener('click', () => this.saveRecording());
                loadButton.addEventListener('click', () => this.loadRecording());
                playButton.addEventListener('click', () => this.playRecording());
            },

            initAudioContext() {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGainNode = audioContext.createGain();
                masterGainNode.gain.setValueAtTime(0.7, audioContext.currentTime);
                compressor = audioContext.createDynamicsCompressor();
                compressor.threshold.setValueAtTime(-24, audioContext.currentTime);
                compressor.knee.setValueAtTime(30, audioContext.currentTime);
                compressor.ratio.setValueAtTime(12, audioContext.currentTime);
                compressor.attack.setValueAtTime(0.003, audioContext.currentTime);
                compressor.release.setValueAtTime(0.25, audioContext.currentTime);
                masterGainNode.connect(compressor);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                compressor.connect(analyser);
                analyser.connect(audioContext.destination);
            },

            start() {
                SynthState.controls = {
                    waveform: document.getElementById('waveform'),
                    unison: document.getElementById('unison'),
                    detune: document.getElementById('detune'),
                    fmAmount: document.getElementById('fmAmount'),
                    filterToggle: document.getElementById('filterToggle'),
                    filterType: document.getElementById('filterType'),
                    filterCutoff: document.getElementById('filterCutoff'),
                    filterResonance: document.getElementById('filterResonance'),
                    filterEnvAmount: document.getElementById('filterEnvAmount'),
                    attack: document.getElementById('attack'),
                    decay: document.getElementById('decay'),
                    sustain: document.getElementById('sustain'),
                    release: document.getElementById('release'),
                    lfoRate: document.getElementById('lfoRate'),
                    lfoAmount: document.getElementById('lfoAmount'),
                    noiseAmount: document.getElementById('noiseAmount'),
                    arpToggle: document.getElementById('arpToggle'),
                    arpPattern: document.getElementById('arpPattern'),
                    arpSpeed: document.getElementById('arpSpeed'),
                    arpClock: document.getElementById('arpClock'),
                    fmToggle: document.getElementById('fmToggle'),
                    lfoToggle: document.getElementById('lfoToggle'),
                    noiseToggle: document.getElementById('noiseToggle'),
                };

                SynthState.controls.fmToggle.checked = SynthState.fmEnabled;
                SynthState.controls.lfoToggle.checked = SynthState.lfoEnabled;
                SynthState.controls.noiseToggle.checked = SynthState.noiseEnabled;

                UI.createPiano();
                UI.initializeEventListeners();
                UI.updateVisualizer();
                this.updateParams();
            },

            updateParams(changedParam) {
                if (changedParam === 'unison' || changedParam === 'detune' || changedParam === 'waveform') {
                    Object.values(SynthState.activeVoices).forEach(voice => {
                        voice.updateVoice();
                    });
                }
                if (changedParam === 'filterToggle') {
                    SynthState.filterEnabled = SynthState.controls.filterToggle.checked;
                } else if (changedParam === 'noiseToggle') {
                    SynthState.noiseEnabled = SynthState.controls.noiseToggle.checked;
                } else if (changedParam === 'lfoToggle') {
                    SynthState.lfoEnabled = SynthState.controls.lfoToggle.checked;
                }

                SynthState.filterSettings.type = SynthState.controls.filterType.value;
                SynthState.filterSettings.frequency = parseFloat(SynthState.controls.filterCutoff.value);
                SynthState.filterSettings.Q = parseFloat(SynthState.controls.filterResonance.value);
                SynthState.fmEnabled = SynthState.controls.fmToggle.checked;

                Object.values(SynthState.activeVoices).forEach(voice => {
                    voice.updateVoice();
                });

                UI.updateCircularControls();
            },

            createMediaStreamFromAudioGraph() {
                const dest = audioContext.createMediaStreamDestination();
                compressor.connect(dest);
                return dest.stream;
            },
            startRecording() {
                this.recordedChunks = [];
                this.recordedNotes = [];
                this.recordingStartTime = audioContext.currentTime;
                const stream = this.createMediaStreamFromAudioGraph();
                this.recorder = new MediaRecorder(stream);
                this.recorder.ondataavailable = (e) => this.recordedChunks.push(e.data);
                this.recorder.start();
                document.getElementById('recordButton').disabled = true;
                document.getElementById('stopButton').disabled = false;
                document.getElementById('playButton').disabled = true;
                document.getElementById('saveButton').disabled = true;
                document.getElementById('exportWavButton').disabled = true;
            },

            recordNoteEvent(note, isNoteOn) {
                if (this.recorder && this.recorder.state === "recording") {
                    const time = audioContext.currentTime - this.recordingStartTime;
                    this.recordedNotes.push({ note, time, isNoteOn });
                }
            },

            stopRecording() {
                this.recorder.stop();
                document.getElementById('recordButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
                document.getElementById('playButton').disabled = false;
                document.getElementById('saveButton').disabled = false;
                document.getElementById('exportWavButton').disabled = false;
            },

            playRecording() {
                if (this.playbackAudio) {
                    this.playbackAudio.currentTime = 0;
                } else if (this.recordedChunks.length > 0) {
                    const blob = new Blob(this.recordedChunks, { type: 'audio/wav' });
                    const audioURL = URL.createObjectURL(blob);
                    this.playbackAudio = new Audio(audioURL);
                } else {
                    console.log('No recording to play');
                    return;
                }

                // Use the main audioContext instead of creating a new one
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                // Create a new source for playback only if it doesn't exist
                if (!this.playbackSource) {
                    this.playbackSource = audioContext.createMediaElementSource(this.playbackAudio);
                    this.playbackSource.connect(compressor);
                }

                this.playbackAudio.play().then(() => {
                    this.animatePlayback();
                    // Use the main updateVisualizer function
                    UI.updateVisualizer();
                }).catch(error => {
                    console.error('Error playing audio:', error);
                });
            },
            
            stopPlayback() {
                if (this.playbackAudio) {
                    this.playbackAudio.pause();
                    this.playbackAudio.currentTime = 0;
                }
                // Clear all active keys
                document.querySelectorAll('.key.active').forEach(key => key.classList.remove('active'));
            },

            animatePlayback() {
                const startTime = audioContext.currentTime;
                let lastUpdateTime = 0;
                const updateInterval = 50; // Update every 50ms

                const animate = () => {
                    if (!this.playbackAudio || this.playbackAudio.paused) {
                        // Clear all active keys at the end of playback
                        document.querySelectorAll('.key.active').forEach(key => key.classList.remove('active'));
                        return;
                    }

                    const currentTime = audioContext.currentTime - startTime;

                    if (currentTime - lastUpdateTime >= updateInterval / 1000) {
                        this.recordedNotes.forEach(noteEvent => {
                            if (Math.abs(noteEvent.time - currentTime) < 0.05) {
                                const keyElement = document.querySelector(`.key[data-note="${noteEvent.note}"]`);
                                if (keyElement) {
                                    if (noteEvent.isNoteOn) {
                                        keyElement.classList.add('active');
                                    } else {
                                        keyElement.classList.remove('active');
                                    }
                                }
                            }
                        });

                        lastUpdateTime = currentTime;
                    }

                    requestAnimationFrame(animate);
                };

                requestAnimationFrame(animate);
            },

            saveRecording() {
                if (this.recordedChunks.length === 0) {
                    console.log('No recording to save');
                    return;
                }

                const blob = new Blob(this.recordedChunks, { type: 'audio/wav' });
                const reader = new FileReader();
                reader.onload = (event) => {
                    const audioData = event.target.result;
                    const presets = this.getPresets();
                    const data = {
                        audio: audioData,
                        presets: presets,
                        notes: this.recordedNotes
                    };
                    const json = JSON.stringify(data);
                    const jsonBlob = new Blob([json], { type: 'application/json' });

                    const saveFile = async () => {
                        try {
                            const handle = await window.showSaveFilePicker({
                                suggestedName: 'browsynth_recording.json',
                                types: [{
                                    description: 'Browsynth Recording',
                                    accept: { 'application/json': ['.json'] },
                                }],
                            });
                            const writable = await handle.createWritable();
                            await writable.write(jsonBlob);
                            await writable.close();
                            console.log('File saved successfully');
                        } catch (err) {
                            console.error('Failed to save file:', err);
                        }
                    };

                    saveFile();
                };
                reader.readAsDataURL(blob);
            },
            exportWav() {
                if (!audioContext) {
                    console.error('AudioContext is not initialized');
                    return;
                }
                if (this.recordedChunks.length === 0) {
                    console.log('No recording to export');
                    return;
                }

                const blob = new Blob(this.recordedChunks, { type: 'audio/wav' });

                blob.arrayBuffer().then(arrayBuffer => {
                    audioContext.decodeAudioData(arrayBuffer, (audioBuffer) => {
                        const wav = this.audioBufferToWav(audioBuffer);
                        const wavBlob = new Blob([new DataView(wav)], { type: 'audio/wav' });

                        const url = URL.createObjectURL(wavBlob);
                        const a = document.createElement('a');
                        document.body.appendChild(a);
                        a.style = 'display: none';
                        a.href = url;
                        a.download = 'browsynth_recording.wav';
                        a.click();
                        window.URL.revokeObjectURL(url);
                    });
                });
            },

            audioBufferToWav(buffer) {
                const numChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const format = 1; // PCM
                const bitDepth = 16;

                let result = new ArrayBuffer(44 + buffer.length * numChannels * 2);
                let view = new DataView(result);

                // RIFF identifier
                this.writeString(view, 0, 'RIFF');
                // RIFF chunk length
                view.setUint32(4, 36 + buffer.length * numChannels * 2, true);
                // RIFF type
                this.writeString(view, 8, 'WAVE');
                // format chunk identifier
                this.writeString(view, 12, 'fmt ');
                // format chunk length
                view.setUint32(16, 16, true);
                // sample format (raw)
                view.setUint16(20, format, true);
                // channel count
                view.setUint16(22, numChannels, true);
                // sample rate
                view.setUint32(24, sampleRate, true);
                // byte rate (sample rate * block align)
                view.setUint32(28, sampleRate * numChannels * 2, true);
                // block align (channel count * bytes per sample)
                view.setUint16(32, numChannels * 2, true);
                // bits per sample
                view.setUint16(34, bitDepth, true);
                // data chunk identifier
                this.writeString(view, 36, 'data');
                // data chunk length
                view.setUint32(40, buffer.length * numChannels * 2, true);

                const length = buffer.length;
                const channels = buffer.numberOfChannels;
                let offset = 44;
                for (let i = 0; i < length; i++) {
                    for (let channel = 0; channel < channels; channel++) {
                        let sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                        view.setInt16(offset, sample, true);
                        offset += 2;
                    }
                }

                return result;
            },

            writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            },

            loadRecording() {
                const loadFile = async () => {
                    try {
                        const [handle] = await window.showOpenFilePicker({
                            types: [{
                                description: 'Browsynth Recording',
                                accept: { 'application/json': ['.json'] },
                            }],
                        });
                        const file = await handle.getFile();
                        const contents = await file.text();
                        const data = JSON.parse(contents);
                        this.setPresets(data.presets);

                        // Create an audio element to play the loaded recording
                        if (this.playbackAudio) {
                            this.playbackAudio.pause();
                            this.playbackAudio.currentTime = 0;
                        }
                        this.playbackAudio = new Audio(data.audio);
                        this.recordedChunks = []; // Clear any existing recorded chunks
                        this.recordedNotes = data.notes || [];
                        fetch(data.audio)
                            .then(res => res.blob())
                            .then(blob => {
                                this.recordedChunks.push(blob);
                            });
                        document.getElementById('playButton').disabled = false;
                        document.getElementById('saveButton').disabled = false;
                        console.log('File loaded successfully');
                    } catch (err) {
                        console.error('Failed to load file:', err);
                    }
                };

                loadFile();
            },

            getPresets() {
                const presets = {};
                for (const [key, control] of Object.entries(SynthState.controls)) {
                    presets[key] = control.type === 'checkbox' ? control.checked : control.value;
                }
                return presets;
            },

            setPresets(presets) {
                for (const [key, value] of Object.entries(presets)) {
                    const control = SynthState.controls[key];
                    if (control) {
                        if (control.type === 'checkbox') {
                            control.checked = value;
                        } else {
                            control.value = value;
                        }
                        this.updateParams(key);
                    }
                }
            },
        };
        // Initialize the synth when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => Synth.initialize());
    </script>
</body>

</html>