<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <title>Browsynth</title>
</head>

<body>
    <div id="startModal" class="modal">
        <div class="modal-content">
            <h2>Welcome to Browsynth</h2>
            <p>Click the button below to start the synthesizer.</p>
            <p>Use your keyboard to play notes.</p>
            <p>Currently not supported on mobile devices.</p>
            <button id="startButton">Start Synth</button>
        </div>
    </div>
    <div id="synth-container">
        <h1>Browsynth</h1>
        <div id="synth-content">
            <div id="piano-and-pitch-bend">
                <div id="piano"></div>
                <div class="pitch-bend-container">
                    <div class="control">
                        <label for="pitchBendWheel">Pitch</label>
                        <div class="vertical-slider-container">
                            <input type="range" id="pitchBendWheel" min="-1" max="1" step="0.01" value="0"
                                class="vertical-slider">
                        </div>
                    </div>
                    <div class="control">
                        <label for="pitchBendRange">Range</label>
                        <div class="range-control">
                            <button id="incrementRange" class="range-button">+</button>
                            <div class="range-value-container">
                                <input type="number" id="pitchBendRange" min="1" max="24" value="2" class="hidden-input"
                                    readonly>
                            </div>
                            <button id="decrementRange" class="range-button">-</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <canvas id="visualizer"></canvas>
        <div id="recorder-controls">
            <button id="recordButton" class="control-button" title="Record">
                <i class="fas fa-microphone"></i>
            </button>
            <button id="stopButton" class="control-button" disabled title="Stop">
                <i class="fas fa-stop"></i>
            </button>
            <button id="playButton" class="control-button" disabled title="Play">
                <i class="fas fa-play"></i>
            </button>
            <button id="saveButton" class="control-button" disabled title="Save">
                <i class="fas fa-save"></i>
            </button>
            <button id="exportWavButton" class="control-button" disabled title="Export WAV">
                <i class="fas fa-file-export"></i>
            </button>
            <button id="loadButton" class="control-button" title="Load">
                <i class="fas fa-folder-open"></i>
            </button>
            <button id="toggleVisualizer" class="control-button" title="Show/Hide Visualizer">
                <i class="fa-solid fa-wave-square"></i>
            </button>
        </div>
        <div id="controls">
            <div class="control-group">
                <h2>Master</h2>
                <div class="control">
                    <label for="masterVolume">Volume</label>
                    <div class="circular-control">
                        <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.7">
                    </div>
                </div>
                <div class="control">
                    <label for="masterReverb">Reverb</label>
                    <div class="circular-control">
                        <input type="range" id="masterReverb" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="masterDelay">Delay</label>
                    <div class="circular-control">
                        <input type="range" id="masterDelay" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="masterLowEQ">Low EQ</label>
                    <div class="circular-control">
                        <input type="range" id="masterLowEQ" min="-12" max="12" step="0.1" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="masterMidEQ">Mid EQ</label>
                    <div class="circular-control">
                        <input type="range" id="masterMidEQ" min="-12" max="12" step="0.1" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="masterHighEQ">High EQ</label>
                    <div class="circular-control">
                        <input type="range" id="masterHighEQ" min="-12" max="12" step="0.1" value="0">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Oscillator</h2>
                <div class="control">
                    <label for="waveform">Waveform</label>
                    <select id="waveform">
                        <option value="sine">Sine</option>
                        <option value="square">Square</option>
                        <option value="sawtooth">Sawtooth</option>
                        <option value="triangle">Triangle</option>
                    </select>
                </div>
                <div class="control">
                    <label for="unison">Unison</label>
                    <div class="circular-control">
                        <input type="range" id="unison" min="1" max="8" step="1" value="1">
                    </div>
                </div>
                <div class="control">
                    <label for="detune">Detune</label>
                    <div class="circular-control">
                        <input type="range" id="detune" min="0" max="100" step="1" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="fmAmount">FM Amount</label>
                    <div class="circular-control">
                        <input type="range" id="fmAmount" min="0" max="1000" step="1" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="fmToggle">FM On/Off</label>
                    <input type="checkbox" id="fmToggle">
                </div>
            </div>
            <div class="control-group">
                <h2>Filter</h2>
                <div class="control">
                    <label for="filterToggle">Filter On/Off</label>
                    <input type="checkbox" id="filterToggle" checked>
                </div>
                <div class="control">
                    <label for="filterType">Filter Type</label>
                    <select id="filterType">
                        <option value="lowpass">Lowpass</option>
                        <option value="highpass">Highpass</option>
                        <option value="bandpass">Bandpass</option>
                    </select>
                </div>
                <div class="control">
                    <label for="filterCutoff">Cutoff</label>
                    <div class="circular-control">
                        <input type="range" id="filterCutoff" min="20" max="20000" step="1" value="20000">
                    </div>
                </div>
                <div class="control">
                    <label for="filterResonance">Resonance</label>
                    <div class="circular-control">
                        <input type="range" id="filterResonance" min="0" max="20" step="0.1" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="filterEnvAmount">Env Amount</label>
                    <div class="circular-control">
                        <input type="range" id="filterEnvAmount" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Envelope</h2>
                <div class="control">
                    <label for="attack">Attack</label>
                    <div class="circular-control">
                        <input type="range" id="attack" min="0" max="2" step="0.01" value="0.05">
                    </div>
                </div>
                <div class="control">
                    <label for="decay">Decay</label>
                    <div class="circular-control">
                        <input type="range" id="decay" min="0" max="2" step="0.01" value="0.1">
                    </div>
                </div>
                <div class="control">
                    <label for="sustain">Sustain</label>
                    <div class="circular-control">
                        <input type="range" id="sustain" min="0" max="1" step="0.01" value="0.5">
                    </div>
                </div>
                <div class="control">
                    <label for="release">Release</label>
                    <div class="circular-control">
                        <input type="range" id="release" min="0" max="5" step="0.01" value="0.5">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>LFO</h2>
                <div class="control">
                    <label for="lfoToggle">LFO On/Off</label>
                    <input type="checkbox" id="lfoToggle">
                </div>
                <div class="control">
                    <label for="lfoRate">Rate</label>
                    <div class="circular-control">
                        <input type="range" id="lfoRate" min="0" max="20" step="0.1" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="lfoAmount">Amount</label>
                    <div class="circular-control">
                        <input type="range" id="lfoAmount" min="0" max="1000" step="1" value="50">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Noise</h2>
                <div class="control">
                    <label for="noiseToggle">Noise On/Off</label>
                    <input type="checkbox" id="noiseToggle">
                </div>
                <div class="control">
                    <label for="noiseAmount">Amount</label>
                    <div class="circular-control">
                        <input type="range" id="noiseAmount" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Arpeggiator</h2>
                <div class="control">
                    <label for="arpToggle">Arp On/Off</label>
                    <input type="checkbox" id="arpToggle">
                </div>
                <div class="control">
                    <label for="arpClock">Clock</label>
                    <select id="arpClock">
                        <option value="1">1/1</option>
                        <option value="2">1/2</option>
                        <option value="4">1/4</option>
                        <option value="8">1/8</option>
                        <option value="16" selected>1/16</option>
                        <option value="32">1/32</option>
                        <option value="64">1/64</option>
                    </select>
                </div>
                <div class="control">
                    <label for="arpPattern">Pattern</label>
                    <select id="arpPattern">
                        <option value="up">Up</option>
                        <option value="down">Down</option>
                        <option value="upDown">Up-Down</option>
                        <option value="random">Random</option>
                    </select>
                </div>
                <div class="control">
                    <label for="arpSpeed">Speed</label>
                    <div class="circular-control">
                        <input type="range" id="arpSpeed" min="1" max="8" step="1" value="4">
                    </div>
                </div>
            </div>
        </div>
        <p id="footer">we like <a href="https://hypertrance.eu/" target="_blank"
                rel="noopener noreferrer">hypertrance</a> ❤️</p>
    </div>
    <script>
        let audioContext;
        let masterGainNode;
        let compressor;
        let analyser;

        // Synth configuration object
        const SynthConfig = {
            waveforms: ['sine', 'square', 'sawtooth', 'triangle'],
            filterTypes: ['lowpass', 'highpass', 'bandpass'],
            notes: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
            whiteNotes: ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
            blackNotes: ['C#', 'D#', 'F#', 'G#', 'A#'],
            keyboardMap: {
                // White keys
                'z': 'C3', 'x': 'D3', 'c': 'E3', 'v': 'F3', 'b': 'G3', 'n': 'A3', 'm': 'B3',
                'q': 'C4', 'w': 'D4', 'e': 'E4', 'r': 'F4', 't': 'G4', 'y': 'A4', 'u': 'B4',
                'i': 'C5', 'o': 'D5', 'p': 'E5', '[': 'F5', ']': 'G5',

                // Black keys
                's': 'C#3', 'd': 'D#3',
                'g': 'F#3', 'h': 'G#3', 'j': 'A#3',
                '2': 'C#4', '3': 'D#4',
                '5': 'F#4', '6': 'G#4', '7': 'A#4',
                '9': 'C#5', '0': 'D#5',
                '=': 'F#5',

                // Additional keys for easier playing
                ',': 'C4', '.': 'D4', '/': 'E4',
                'a': 'A3', 'k': 'B3', 'l': 'C4', ';': 'D4', "'": 'E4',

                // Keep Turkish keyboard support
                'ı': 'C5', 'ğ': 'F5', 'ü': 'G5',
                'ö': 'C4', 'ç': 'D4'
            },
            maxPolyphony: 8,
        };

        // Synth state
        const SynthState = {
            activeVoices: {},
            activeNotes: new Set(),
            controls: {},
            fmEnabled: false,
            lfoEnabled: false,
            noiseEnabled: false,
            arpeggiator: {
                isOn: false,
                pattern: 'up',
                speed: 4, // Default speed (middle of the range 1-8)
                notes: [],
                currentIndex: 0,
                intervalId: null
            },
            filterEnabled: true,
            filterSettings: {
                type: 'lowpass',
                frequency: 1000,
                Q: 0
            },
        };

        // Utility functions
        const Util = {
            noteToFreq(note) {
                if (!note) {
                    console.error('Invalid note:', note);
                    return 0;
                }

                let [noteName, octave] = note.match(/([A-G]#?)(\d+)/).slice(1);
                octave = parseInt(octave);

                const noteIndex = SynthConfig.notes.indexOf(noteName);
                if (noteIndex === -1) {
                    console.error('Invalid note name:', noteName);
                    return 0;
                }

                return 440 * Math.pow(2, (noteIndex - 9) / 12 + (octave - 4));
            },

            createNoiseBuffer() {
                if (!audioContext) return null;
                const bufferSize = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                return buffer;
            },
        };

        // Synth voice creation and management
        const Voice = {
            create(note) {
                if (!Synth.audioContext) return null;
                const frequency = Util.noteToFreq(note);
                const now = Synth.audioContext.currentTime;

                const oscillators = [];
                const unisonCount = parseInt(SynthState.controls.unison.value) || 1;
                const detune = parseFloat(SynthState.controls.detune.value) || 0;

                for (let i = 0; i < unisonCount; i++) {
                    const osc = Synth.audioContext.createOscillator();
                    osc.type = SynthState.controls.waveform.value;
                    osc.frequency.setValueAtTime(frequency, now);
                    const detuneAmount = unisonCount > 1 ? (i / (unisonCount - 1) - 0.5) * detune : 0;
                    osc.detune.setValueAtTime(detuneAmount, now);
                    oscillators.push(osc);
                }

                const gainNode = Synth.audioContext.createGain();
                gainNode.gain.setValueAtTime(0, now);

                const filter = Synth.audioContext.createBiquadFilter();
                filter.type = SynthState.filterSettings.type;
                filter.frequency.setValueAtTime(SynthState.filterSettings.frequency, now);
                filter.Q.setValueAtTime(SynthState.filterSettings.Q, now);

                // Connect nodes based on filter state
                if (SynthState.filterEnabled) {
                    oscillators.forEach(osc => osc.connect(filter));
                    filter.connect(gainNode);
                } else {
                    oscillators.forEach(osc => osc.connect(gainNode));
                }

                const fmOsc = Synth.audioContext.createOscillator();
                fmOsc.frequency.setValueAtTime(frequency * 2, now);
                const fmGain = Synth.audioContext.createGain();
                fmGain.gain.setValueAtTime(0, now);

                const noiseOsc = Synth.audioContext.createBufferSource();
                noiseOsc.buffer = Util.createNoiseBuffer();
                noiseOsc.loop = true;
                const noiseGain = Synth.audioContext.createGain();
                noiseGain.gain.setValueAtTime(0, now);

                const lfo = Synth.audioContext.createOscillator();
                const lfoGain = Synth.audioContext.createGain();
                lfo.frequency.setValueAtTime(parseFloat(SynthState.controls.lfoRate.value), now);
                lfoGain.gain.setValueAtTime(parseFloat(SynthState.controls.lfoAmount.value), now);

                // Connect LFO
                if (SynthState.lfoEnabled) {
                    lfo.connect(lfoGain);
                    lfoGain.connect(filter.frequency);
                }

                const pitchBend = {
                    bend: 0,
                    range: parseInt(SynthState.controls.pitchBendRange?.value) || 2
                };

                const updatePitchBend = (bend) => {
                    const now = Synth.audioContext.currentTime;
                    const bendRange = pitchBend.range * 100; // Convert semitones to cents
                    oscillators.forEach((osc, i) => {
                        const detuneAmount = unisonCount > 1 ? (i / (unisonCount - 1) - 0.5) * detune : 0;
                        const totalDetune = detuneAmount + bend * bendRange;

                        // Ensure the value is finite and within a reasonable range
                        const clampedDetune = Math.max(-4800, Math.min(4800, isFinite(totalDetune) ? totalDetune : 0));

                        osc.detune.setTargetAtTime(clampedDetune, now, 0.01);
                    });
                };

                gainNode.connect(Synth.compressor);

                // Start oscillators
                oscillators.forEach(osc => osc.start(now));
                fmOsc.start(now);
                noiseOsc.start(now);
                lfo.start(now);

                const updateVoice = () => {
                    const now = Synth.audioContext.currentTime;

                    // Update filter
                    if (SynthState.filterEnabled) {
                        filter.type = SynthState.filterSettings.type;
                        filter.frequency.cancelScheduledValues(now);
                        filter.frequency.setValueAtTime(SynthState.filterSettings.frequency, now);
                        filter.Q.cancelScheduledValues(now);
                        filter.Q.setValueAtTime(SynthState.filterSettings.Q, now);

                        oscillators.forEach(osc => {
                            osc.disconnect();
                            osc.connect(filter);
                        });
                        filter.disconnect();
                        filter.connect(gainNode);
                    } else {
                        oscillators.forEach(osc => {
                            osc.disconnect();
                            osc.connect(gainNode);
                        });
                    }

                    // Update oscillators, unison, and detune
                    const newUnisonCount = parseInt(SynthState.controls.unison.value) || 1;
                    const newDetune = parseFloat(SynthState.controls.detune.value) || 0;

                    // Adjust the number of oscillators if unison has changed
                    while (oscillators.length < newUnisonCount) {
                        const newOsc = Synth.audioContext.createOscillator();
                        newOsc.type = SynthState.controls.waveform.value;
                        newOsc.frequency.setValueAtTime(frequency, now);
                        newOsc.start(now);
                        oscillators.push(newOsc);
                    }
                    while (oscillators.length > newUnisonCount) {
                        const oscToRemove = oscillators.pop();
                        oscToRemove.stop(now);
                        oscToRemove.disconnect();
                    }

                    // Update each oscillator
                    oscillators.forEach((osc, i) => {
                        osc.type = SynthState.controls.waveform.value;
                        const detuneAmount = newUnisonCount > 1 ? (i / (newUnisonCount - 1) - 0.5) * newDetune : 0;
                        osc.detune.setValueAtTime(detuneAmount, now);

                        // Reconnect oscillator if filter state has changed
                        osc.disconnect();
                        if (SynthState.filterEnabled) {
                            osc.connect(filter);
                        } else {
                            osc.connect(gainNode);
                        }
                    });

                    // Update FM
                    if (SynthState.fmEnabled) {
                        fmGain.gain.setValueAtTime(parseFloat(SynthState.controls.fmAmount.value), now);
                    } else {
                        fmGain.gain.setValueAtTime(0, now);
                    }

                    // Update Noise
                    if (SynthState.noiseEnabled) {
                        noiseGain.gain.setValueAtTime(parseFloat(SynthState.controls.noiseAmount.value), now);
                        noiseOsc.connect(noiseGain);
                        noiseGain.connect(SynthState.filterEnabled ? filter : gainNode);
                    } else {
                        noiseGain.gain.setValueAtTime(0, now);
                        noiseOsc.disconnect();
                        noiseGain.disconnect();
                    }

                    // Update LFO
                    if (SynthState.lfoEnabled) {
                        lfo.frequency.setValueAtTime(parseFloat(SynthState.controls.lfoRate.value), now);
                        lfoGain.gain.setValueAtTime(parseFloat(SynthState.controls.lfoAmount.value), now);
                        lfo.connect(lfoGain);
                        lfoGain.connect(filter.frequency);
                    } else {
                        lfo.disconnect();
                        lfoGain.disconnect();
                    }
                };

                return {
                    oscillators, gainNode, filter, fmOsc, fmGain, noiseOsc, noiseGain, lfo, lfoGain, updateVoice, updatePitchBend, pitchBend, frequency
                };
            },

            play(note, isArpeggiator = false) {
                if (!Synth.audioContext) return;
                if (SynthState.arpeggiator.isOn && !isArpeggiator) {
                    Arpeggiator.addNote(note);
                    return;
                }
                if (SynthState.activeVoices[note]) return;

                if (Object.keys(SynthState.activeVoices).length >= SynthConfig.maxPolyphony) {
                    const oldestNote = Object.keys(SynthState.activeVoices)[0];
                    this.release(oldestNote);
                }

                const voice = this.create(note);
                if (voice && voice.updatePitchBend) {
                    const currentPitchBend = parseFloat(SynthState.controls.pitchBendWheel?.value) || 0;
                    voice.updatePitchBend(currentPitchBend);
                }
                SynthState.activeVoices[note] = voice;
                SynthState.activeNotes.add(note);
                Synth.recordNoteEvent(note, true);

                const now = Synth.audioContext.currentTime;
                const attackTime = parseFloat(SynthState.controls.attack.value);
                const decayTime = parseFloat(SynthState.controls.decay.value);
                const sustainLevel = parseFloat(SynthState.controls.sustain.value);

                // Adjust the peak level based on the number of active voices
                const peakLevel = 0.5 / Math.max(1, Math.sqrt(Object.keys(SynthState.activeVoices).length));
                const sustainedLevel = sustainLevel * peakLevel;

                voice.gainNode.gain.linearRampToValueAtTime(peakLevel, now + attackTime);
                voice.gainNode.gain.linearRampToValueAtTime(sustainedLevel, now + attackTime + decayTime);

                // Filter envelope
                const filterEnvAmount = parseFloat(SynthState.controls.filterEnvAmount.value);
                const filterStartFreq = SynthState.filterSettings.frequency;
                const filterPeakFreq = Math.min(filterStartFreq * (1 + filterEnvAmount * 10), Synth.audioContext.sampleRate / 2);

                // Apply noise envelope
                if (SynthState.noiseEnabled) {
                    const noiseAmount = parseFloat(SynthState.controls.noiseAmount.value);
                    voice.noiseGain.gain.cancelScheduledValues(now);
                    voice.noiseGain.gain.setValueAtTime(0, now);
                    voice.noiseGain.gain.linearRampToValueAtTime(noiseAmount, now + attackTime);
                    voice.noiseGain.gain.linearRampToValueAtTime(noiseAmount * sustainLevel, now + attackTime + decayTime);
                }

                // Apply LFO envelope
                if (SynthState.lfoEnabled) {
                    const lfoAmount = parseFloat(SynthState.controls.lfoAmount.value);
                    voice.lfoGain.gain.cancelScheduledValues(now);
                    voice.lfoGain.gain.setValueAtTime(0, now);
                    voice.lfoGain.gain.linearRampToValueAtTime(lfoAmount, now + attackTime);
                }

                if (SynthState.filterEnabled) {
                    voice.filter.frequency.cancelScheduledValues(now);
                    voice.filter.frequency.setValueAtTime(filterStartFreq, now);
                    voice.filter.frequency.linearRampToValueAtTime(filterPeakFreq, now + attackTime);
                    voice.filter.frequency.linearRampToValueAtTime(filterStartFreq, now + attackTime + decayTime);
                }

                const keyElement = document.querySelector(`.key[data-note="${note}"]`);
                if (keyElement) keyElement.classList.add('active');
            },

            release(note, isArpeggiator = false) {
                if (SynthState.arpeggiator.isOn && !isArpeggiator) {
                    Arpeggiator.removeNote(note);
                    return;
                }

                const voice = SynthState.activeVoices[note];
                Synth.recordNoteEvent(note, false);
                if (!voice) return;

                const now = Synth.audioContext.currentTime;
                const releaseTime = parseFloat(SynthState.controls.release.value);

                voice.gainNode.gain.cancelScheduledValues(now);
                voice.gainNode.gain.setValueAtTime(voice.gainNode.gain.value, now);
                voice.gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);

                // Apply noise release
                if (SynthState.noiseEnabled) {
                    voice.noiseGain.gain.cancelScheduledValues(now);
                    voice.noiseGain.gain.setValueAtTime(voice.noiseGain.gain.value, now);
                    voice.noiseGain.gain.linearRampToValueAtTime(0, now + releaseTime);
                }

                // Apply LFO release
                if (SynthState.lfoEnabled) {
                    voice.lfoGain.gain.cancelScheduledValues(now);
                    voice.lfoGain.gain.setValueAtTime(voice.lfoGain.gain.value, now);
                    voice.lfoGain.gain.linearRampToValueAtTime(0, now + releaseTime);
                }

                setTimeout(() => {
                    voice.oscillators.forEach(osc => {
                        osc.stop();
                        osc.disconnect();
                    });
                    voice.gainNode.disconnect();
                    voice.filter.disconnect();
                    voice.fmOsc.stop();
                    voice.fmOsc.disconnect();
                    voice.fmGain.disconnect();
                    voice.noiseOsc.stop();
                    voice.noiseOsc.disconnect();
                    voice.noiseGain.disconnect();
                    voice.lfo.stop();
                    voice.lfo.disconnect();
                    voice.lfoGain.disconnect();
                }, releaseTime * 1000);

                delete SynthState.activeVoices[note];
                SynthState.activeNotes.delete(note);

                const keyElement = document.querySelector(`.key[data-note="${note}"]`);
                if (keyElement) keyElement.classList.remove('active');
            },

            stopAllNotes: function (isArpeggiator = false) {
                if (SynthState.arpeggiator.isOn && !isArpeggiator) {
                    Arpeggiator.stop();
                    return;
                }
                SynthState.activeNotes.forEach(note => {
                    if (SynthState.activeVoices[note]) {
                        this.release(note, true);
                    }
                });
                SynthState.activeNotes.clear();
                const keys = document.querySelectorAll('.key.active');
                keys.forEach(key => key.classList.remove('active'));
            }
        };
        // Bind the method to the Voice object
        Voice.stopAllNotes = Voice.stopAllNotes.bind(Voice);
        // Arpeggiator functionality
        const Arpeggiator = {
            step: 0,
            direction: 1,

            start() {
                if (SynthState.arpeggiator.notes.length === 0) return;
                this.stop();
                this.step = 0;
                this.direction = 1;
                this.playCurrentNote();
                const speed = this.calculateSpeed();
                SynthState.arpeggiator.intervalId = setInterval(() => this.playNextNote(), speed);
            },

            stop() {
                if (SynthState.arpeggiator.intervalId) {
                    clearInterval(SynthState.arpeggiator.intervalId);
                    SynthState.arpeggiator.intervalId = null;
                }
                Voice.stopAllNotes(true);
            },

            calculateSpeed() {
                const clockValue = parseInt(SynthState.controls.arpClock.value);
                const speedValue = parseInt(SynthState.controls.arpSpeed.value);
                // Base speed of 500ms (120 BPM) divided by clock division and multiplied by speed factor
                return (500 / clockValue) * (9 - speedValue);
            },

            updateSpeed() {
                if (SynthState.arpeggiator.isOn && SynthState.arpeggiator.notes.length > 0) {
                    this.stop();
                    this.start();
                }
            },

            addNote(note) {
                if (!SynthState.arpeggiator.notes.includes(note)) {
                    SynthState.arpeggiator.notes.push(note);
                }
                if (SynthState.arpeggiator.isOn && SynthState.arpeggiator.notes.length === 1) {
                    this.start();
                }
            },

            removeNote(note) {
                const index = SynthState.arpeggiator.notes.indexOf(note);
                if (index > -1) {
                    SynthState.arpeggiator.notes.splice(index, 1);
                }
                if (SynthState.arpeggiator.notes.length === 0) {
                    this.stop();
                }
            },

            playNextNote() {
                if (SynthState.arpeggiator.notes.length === 0) {
                    this.stop();
                    return;
                }
                this.step = this.getNextStep();
                this.playCurrentNote();
            },

            playCurrentNote() {
                if (SynthState.arpeggiator.notes.length === 0) return;
                const note = SynthState.arpeggiator.notes[this.step];
                Voice.stopAllNotes(true);
                Voice.play(note, true);
            },

            getNextStep() {
                const { pattern, notes } = SynthState.arpeggiator;
                const notesCount = notes.length;
                switch (pattern) {
                    case 'up':
                        return (this.step + 1) % notesCount;
                    case 'down':
                        return (this.step - 1 + notesCount) % notesCount;
                    case 'upDown':
                        if (this.step === 0) this.direction = 1;
                        else if (this.step === notesCount - 1) this.direction = -1;
                        return (this.step + this.direction + notesCount) % notesCount;
                    case 'random':
                        return Math.floor(Math.random() * notesCount);
                    default:
                        return (this.step + 1) % notesCount;
                }
            },
        };
        // UI related functions
        const UI = {
            createPiano() {
                const piano = document.getElementById('piano');
                piano.innerHTML = '';
                for (let octave = 1; octave < 7; octave++) {
                    SynthConfig.whiteNotes.forEach(note => {
                        const key = document.createElement('div');
                        key.className = 'key';
                        key.dataset.note = note + octave;
                        piano.appendChild(key);
                    });
                }

                const whiteKeys = piano.querySelectorAll('.key');
                let blackKeyIndex = 0;
                whiteKeys.forEach((whiteKey, index) => {
                    if (index % 7 !== 2 && index % 7 !== 6) {
                        const blackKey = document.createElement('div');
                        blackKey.className = 'key black';
                        blackKey.dataset.note = SynthConfig.blackNotes[blackKeyIndex % 5] + (Math.floor(index / 7) + 1);
                        whiteKey.parentNode.insertBefore(blackKey, whiteKey.nextSibling);
                        blackKeyIndex++;
                    }
                });
            },

            toggleVisualizer() {
                this.visualizerEnabled = !this.visualizerEnabled;
                const visualizer = document.getElementById('visualizer');
                const toggleButton = document.getElementById('toggleVisualizer');

                if (this.visualizerEnabled) {
                    visualizer.style.display = 'block';
                    this.updateVisualizer();
                } else {
                    visualizer.style.display = 'none';
                }
            },
            updateCircularControls() {
                document.querySelectorAll('.circular-control input[type="range"]').forEach(input => {
                    const value = parseFloat(input.value);
                    const min = parseFloat(input.min);
                    const max = parseFloat(input.max);
                    const normalizedValue = (value - min) / (max - min);
                    const rotation = normalizedValue * 270 - 135; // Map 0-1 to -135deg to 135deg
                    input.parentNode.style.setProperty('--rotation', `${rotation}deg`);
                });
            },

            handleCircularControlInteraction(event) {
                const control = event.currentTarget;
                const input = control.querySelector('input[type="range"]');
                let startY, startValue;

                function handleStart(e) {
                    startY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                    startValue = parseFloat(input.value);
                    document.addEventListener('mousemove', handleMove);
                    document.addEventListener('touchmove', handleMove, { passive: false });
                    document.addEventListener('mouseup', handleEnd);
                    document.addEventListener('touchend', handleEnd);
                }

                function handleMove(e) {
                    const currentY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                    const deltaY = startY - currentY;
                    const range = input.max - input.min;
                    const valueChange = (deltaY / 100) * range;
                    let newValue = Math.max(input.min, Math.min(input.max, startValue + valueChange));

                    input.value = newValue;
                    Synth.updateParams();
                    input.dispatchEvent(new Event('input'));
                    e.preventDefault();
                }

                function handleEnd() {
                    document.removeEventListener('mousemove', handleMove);
                    document.removeEventListener('touchmove', handleMove);
                    document.removeEventListener('mouseup', handleEnd);
                    document.removeEventListener('touchend', handleEnd);
                }

                if (event.type === 'mousedown') {
                    handleStart(event);
                } else if (event.type === 'touchstart') {
                    handleStart(event);
                }
            },
            initializeEventListeners() {
                const keys = document.querySelectorAll('.key');
                let isMouseDown = false;
                let lastPlayedNote = null;

                keys.forEach(key => {
                    key.addEventListener('mousedown', (e) => {
                        isMouseDown = true;
                        const note = e.target.dataset.note;
                        Voice.play(note);
                        lastPlayedNote = note;
                    });

                    key.addEventListener('mouseenter', (e) => {
                        if (isMouseDown) {
                            const note = e.target.dataset.note;
                            if (note !== lastPlayedNote) {
                                Voice.release(lastPlayedNote);
                                Voice.play(note);
                                lastPlayedNote = note;
                            }
                        }
                    });

                    key.addEventListener('mouseleave', (e) => {
                        if (isMouseDown) {
                            const note = e.target.dataset.note;
                            Voice.release(note);
                        }
                    });
                });

                document.addEventListener('mouseup', () => {
                    if (isMouseDown) {
                        Voice.release(lastPlayedNote);
                        isMouseDown = false;
                        lastPlayedNote = null;
                    }
                });

                document.getElementById('piano').addEventListener('selectstart', (e) => e.preventDefault());

                // Control event listeners
                Object.entries(SynthState.controls).forEach(([key, control]) => {
                    if (control.type === 'checkbox') {
                        control.addEventListener('change', () => Synth.updateParams(key));
                    } else {
                        control.addEventListener('input', () => Synth.updateParams(key));
                    }
                });

                // Arpeggiator controls
                SynthState.controls.arpToggle.addEventListener('change', (e) => {
                    SynthState.arpeggiator.isOn = e.target.checked;
                    if (SynthState.arpeggiator.isOn) {
                        if (SynthState.arpeggiator.notes.length > 0) {
                            Arpeggiator.start();
                        }
                    } else {
                        Arpeggiator.stop();
                    }
                });

                SynthState.controls.masterVolume.addEventListener('input', () => Synth.updateParams('masterVolume'));
                SynthState.controls.masterReverb.addEventListener('input', () => Synth.updateParams('masterReverb'));
                SynthState.controls.masterDelay.addEventListener('input', () => Synth.updateParams('masterDelay'));
                SynthState.controls.masterLowEQ.addEventListener('input', () => Synth.updateParams('masterLowEQ'));
                SynthState.controls.masterMidEQ.addEventListener('input', () => Synth.updateParams('masterMidEQ'));
                SynthState.controls.masterHighEQ.addEventListener('input', () => Synth.updateParams('masterHighEQ'));
                SynthState.controls.filterToggle.addEventListener('change', () => Synth.updateParams('filterToggle'));
                SynthState.controls.arpSpeed.addEventListener('input', Arpeggiator.updateSpeed);
                SynthState.controls.arpClock.addEventListener('change', Arpeggiator.updateSpeed);
                SynthState.controls.arpPattern.addEventListener('change', Arpeggiator.updateSpeed);
                SynthState.controls.noiseToggle.addEventListener('change', () => Synth.updateParams('noiseToggle'));
                SynthState.controls.noiseAmount.addEventListener('input', () => Synth.updateParams('noiseAmount'));
                SynthState.controls.lfoToggle.addEventListener('change', () => Synth.updateParams('lfoToggle'));
                SynthState.controls.lfoRate.addEventListener('input', () => Synth.updateParams('lfoRate'));
                SynthState.controls.lfoAmount.addEventListener('input', () => Synth.updateParams('lfoAmount'));
                SynthState.controls.unison.addEventListener('input', () => Synth.updateParams('unison'));
                SynthState.controls.detune.addEventListener('input', () => Synth.updateParams('detune'));
                SynthState.controls.waveform.addEventListener('change', () => Synth.updateParams('waveform'));
                SynthState.controls.pitchBendWheel.addEventListener('input', (e) => {
                    const bend = parseFloat(e.target.value);
                    Synth.updatePitchBend(bend);
                });

                SynthState.controls.pitchBendRange.addEventListener('input', (e) => {
                    const range = parseInt(e.target.value);
                    Synth.updatePitchBendRange(range);
                });

                SynthState.controls.pitchBendWheel.addEventListener('mouseup', (e) => {
                    e.target.value = 0;
                    Synth.updatePitchBend(0);
                });

                SynthState.controls.pitchBendWheel.addEventListener('touchend', (e) => {
                    e.target.value = 0;
                    Synth.updatePitchBend(0);
                });
                // Keyboard controls
                document.addEventListener('keydown', (event) => {
                    const note = SynthConfig.keyboardMap[event.key.toLowerCase()];
                    if (note && !event.repeat) {
                        Voice.play(note);
                    }
                });

                document.addEventListener('keyup', (event) => {
                    const note = SynthConfig.keyboardMap[event.key.toLowerCase()];
                    if (note) {
                        Voice.release(note);
                    }
                });

                window.addEventListener('blur', () => Voice.stopAllNotes());
                window.addEventListener('resize', this.updateVisualizer);

                document.querySelectorAll('.circular-control').forEach(control => {
                    control.addEventListener('mousedown', this.handleCircularControlInteraction);
                    control.addEventListener('touchstart', this.handleCircularControlInteraction, { passive: false });
                });

                const toggleVisualizerButton = document.getElementById('toggleVisualizer');
                toggleVisualizerButton.addEventListener('click', () => Synth.toggleVisualizer());
            }
        };

        // Main Synth object
        const Synth = {
            recorder: null,
            recordedChunks: [],
            recordedNotes: [],
            recordingStartTime: 0,
            audioContext: null,
            compressor: null,
            playbackAudio: null,
            playbackSource: null,
            masterReverb: null,
            masterDelay: null,
            masterLowEQ: null,
            masterMidEQ: null,
            masterHighEQ: null,
            visualizerEnabled: true,

            initialize() {
                const startButton = document.getElementById('startButton');
                const startModal = document.getElementById('startModal');
                const exportWavButton = document.getElementById('exportWavButton');
                exportWavButton.addEventListener('click', () => this.exportWav());

                startButton.addEventListener('click', () => {
                    this.initAudioContext();
                    startModal.style.display = 'none';
                    this.start();
                });

                const recordButton = document.getElementById('recordButton');
                const stopButton = document.getElementById('stopButton');
                const saveButton = document.getElementById('saveButton');
                const loadButton = document.getElementById('loadButton');
                const playButton = document.getElementById('playButton');

                recordButton.addEventListener('click', () => this.startRecording());
                stopButton.addEventListener('click', () => this.stopRecording());
                saveButton.addEventListener('click', () => this.saveRecording());
                loadButton.addEventListener('click', () => this.loadRecording());
                playButton.addEventListener('click', () => this.playRecording());

                // Initialize pitch bend controls
                SynthState.controls.pitchBendWheel = document.getElementById('pitchBendWheel');
                SynthState.controls.pitchBendRange = document.getElementById('pitchBendRange');

                // Ensure pitchBendRange is not null before proceeding
                if (SynthState.controls.pitchBendRange === null) {
                    console.error('pitchBendRange element not found');
                }
            },

            start() {
                SynthState.controls = {
                    masterVolume: document.getElementById('masterVolume'),
                    masterReverb: document.getElementById('masterReverb'),
                    masterDelay: document.getElementById('masterDelay'),
                    masterLowEQ: document.getElementById('masterLowEQ'),
                    masterMidEQ: document.getElementById('masterMidEQ'),
                    masterHighEQ: document.getElementById('masterHighEQ'),
                    waveform: document.getElementById('waveform'),
                    unison: document.getElementById('unison'),
                    detune: document.getElementById('detune'),
                    fmAmount: document.getElementById('fmAmount'),
                    filterToggle: document.getElementById('filterToggle'),
                    filterType: document.getElementById('filterType'),
                    filterCutoff: document.getElementById('filterCutoff'),
                    filterResonance: document.getElementById('filterResonance'),
                    filterEnvAmount: document.getElementById('filterEnvAmount'),
                    attack: document.getElementById('attack'),
                    decay: document.getElementById('decay'),
                    sustain: document.getElementById('sustain'),
                    release: document.getElementById('release'),
                    lfoRate: document.getElementById('lfoRate'),
                    lfoAmount: document.getElementById('lfoAmount'),
                    noiseAmount: document.getElementById('noiseAmount'),
                    arpToggle: document.getElementById('arpToggle'),
                    arpPattern: document.getElementById('arpPattern'),
                    arpSpeed: document.getElementById('arpSpeed'),
                    arpClock: document.getElementById('arpClock'),
                    fmToggle: document.getElementById('fmToggle'),
                    lfoToggle: document.getElementById('lfoToggle'),
                    noiseToggle: document.getElementById('noiseToggle'),
                    pitchBendWheel: document.getElementById('pitchBendWheel'),
                    pitchBendRange: document.getElementById('pitchBendRange'),
                };

                SynthState.controls.fmToggle.checked = SynthState.fmEnabled;
                SynthState.controls.lfoToggle.checked = SynthState.lfoEnabled;
                SynthState.controls.noiseToggle.checked = SynthState.noiseEnabled;

                // Ensure pitchBendRange is not null before using its value
                if (SynthState.controls.pitchBendRange === null) {
                    console.error('pitchBendRange element not found');
                } else {
                    // Initialize pitch bend range
                    this.updatePitchBendRange(parseInt(SynthState.controls.pitchBendRange.value) || 2);
                }

                // Set initial values for controls
                this.updateMasterVolume();
                this.updateMasterReverb();
                this.updateMasterDelay();
                this.updateMasterEQ();

                UI.createPiano();
                UI.initializeEventListeners();
                this.updateVisualizer();
                this.updateParams();
            },
            initAudioContext() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGainNode = this.audioContext.createGain();
                this.masterGainNode.gain.setValueAtTime(0.7, this.audioContext.currentTime);

                this.masterReverb = this.createReverbEffect();
                const delayEffect = this.createDelayEffect();
                this.masterDelay = delayEffect.delayNode;
                this.delayFeedback = delayEffect.feedbackGain;
                this.masterLowEQ = this.audioContext.createBiquadFilter();
                this.masterMidEQ = this.audioContext.createBiquadFilter();
                this.masterHighEQ = this.audioContext.createBiquadFilter();

                this.compressor = this.audioContext.createDynamicsCompressor();
                this.compressor.threshold.setValueAtTime(-24, this.audioContext.currentTime);
                this.compressor.knee.setValueAtTime(30, this.audioContext.currentTime);
                this.compressor.ratio.setValueAtTime(12, this.audioContext.currentTime);
                this.compressor.attack.setValueAtTime(0.003, this.audioContext.currentTime);
                this.compressor.release.setValueAtTime(0.25, this.audioContext.currentTime);

                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 2048;

                // Create dry/wet gains for reverb and delay
                this.reverbDry = this.audioContext.createGain();
                this.reverbWet = this.audioContext.createGain();
                this.delayDry = this.audioContext.createGain();
                this.delayWet = this.audioContext.createGain();

                // Connect the nodes
                this.compressor.connect(this.masterLowEQ);
                this.masterLowEQ.connect(this.masterMidEQ);
                this.masterMidEQ.connect(this.masterHighEQ);
                this.masterHighEQ.connect(this.reverbDry);
                this.masterHighEQ.connect(this.reverbWet);
                this.reverbWet.connect(this.masterReverb);
                this.masterReverb.connect(this.delayDry);
                this.reverbDry.connect(this.delayDry);
                this.delayDry.connect(this.delayWet);
                this.delayWet.connect(this.masterDelay);
                this.masterDelay.connect(this.delayFeedback);
                this.delayFeedback.connect(this.masterDelay);
                this.masterDelay.connect(this.masterGainNode);
                this.delayDry.connect(this.masterGainNode);
                this.masterGainNode.connect(this.analyser);
                this.analyser.connect(this.audioContext.destination);
                // Start the visualizer
                this.updateVisualizer();

                // Set up EQ filters
                this.masterLowEQ.type = 'lowshelf';
                this.masterLowEQ.frequency.value = 200;
                this.masterMidEQ.type = 'peaking';
                this.masterMidEQ.frequency.value = 1000;
                this.masterMidEQ.Q.value = 1;
                this.masterHighEQ.type = 'highshelf';
                this.masterHighEQ.frequency.value = 3000;

                // Initialize delay
                this.masterDelay.delayTime.value = 0.5;
                this.delayWet.gain.value = 0;
                this.delayDry.gain.value = 1;

                // Initialize reverb
                this.reverbWet.gain.value = 0;
                this.reverbDry.gain.value = 1;
            },

            createReverbEffect() {
                const reverbNode = this.audioContext.createConvolver();
                const length = this.audioContext.sampleRate * 4; // 4 seconds
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                const impulseL = impulse.getChannelData(0);
                const impulseR = impulse.getChannelData(1);

                for (let i = 0; i < length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const decay = Math.exp(-t * 3); // Adjust decay rate
                    impulseL[i] = (Math.random() * 2 - 1) * decay;
                    impulseR[i] = (Math.random() * 2 - 1) * decay;
                }

                reverbNode.buffer = impulse;
                return reverbNode;
            },

            createDelayEffect() {
                const delayNode = this.audioContext.createDelay(5.0);
                const feedbackGain = this.audioContext.createGain();

                delayNode.delayTime.value = 0.5; // 500ms delay
                feedbackGain.gain.value = 0.3; // 30% feedback

                delayNode.connect(feedbackGain);
                feedbackGain.connect(delayNode);

                return { delayNode, feedbackGain };
            },

            incrementPitchBendRange() {
                const currentRange = parseInt(SynthState.controls.pitchBendRange.value) || 2;
                const newRange = Math.min(24, currentRange + 1); // Max range is 24 semitones
                SynthState.controls.pitchBendRange.value = newRange;
                this.updatePitchBendRange(newRange);
            },

            decrementPitchBendRange() {
                const currentRange = parseInt(SynthState.controls.pitchBendRange.value) || 2;
                const newRange = Math.max(1, currentRange - 1); // Min range is 1 semitone
                SynthState.controls.pitchBendRange.value = newRange;
                this.updatePitchBendRange(newRange);
            },

            updatePitchBendRange(range) {
                const clampedRange = Math.max(1, Math.min(24, range)); // Clamp range between 1 and 24 semitones
                Object.values(SynthState.activeVoices).forEach(voice => {
                    voice.pitchBend.range = clampedRange;
                    voice.updatePitchBend(voice.pitchBend.bend);
                });
            },

            updatePitchBend(bend) {
                Object.values(SynthState.activeVoices).forEach(voice => {
                    if (voice.updatePitchBend) {
                        voice.updatePitchBend(bend);
                    }
                });
            },

            start() {
                SynthState.controls = {
                    masterVolume: document.getElementById('masterVolume'),
                    masterReverb: document.getElementById('masterReverb'),
                    masterDelay: document.getElementById('masterDelay'),
                    masterLowEQ: document.getElementById('masterLowEQ'),
                    masterMidEQ: document.getElementById('masterMidEQ'),
                    masterHighEQ: document.getElementById('masterHighEQ'),
                    waveform: document.getElementById('waveform'),
                    unison: document.getElementById('unison'),
                    detune: document.getElementById('detune'),
                    fmAmount: document.getElementById('fmAmount'),
                    filterToggle: document.getElementById('filterToggle'),
                    filterType: document.getElementById('filterType'),
                    filterCutoff: document.getElementById('filterCutoff'),
                    filterResonance: document.getElementById('filterResonance'),
                    filterEnvAmount: document.getElementById('filterEnvAmount'),
                    attack: document.getElementById('attack'),
                    decay: document.getElementById('decay'),
                    sustain: document.getElementById('sustain'),
                    release: document.getElementById('release'),
                    lfoRate: document.getElementById('lfoRate'),
                    lfoAmount: document.getElementById('lfoAmount'),
                    noiseAmount: document.getElementById('noiseAmount'),
                    arpToggle: document.getElementById('arpToggle'),
                    arpPattern: document.getElementById('arpPattern'),
                    arpSpeed: document.getElementById('arpSpeed'),
                    arpClock: document.getElementById('arpClock'),
                    fmToggle: document.getElementById('fmToggle'),
                    lfoToggle: document.getElementById('lfoToggle'),
                    noiseToggle: document.getElementById('noiseToggle'),
                    pitchBendWheel: document.getElementById('pitchBendWheel'),
                    pitchBendRange: document.getElementById('pitchBendRange'),
                };

                SynthState.controls.fmToggle.checked = SynthState.fmEnabled;
                SynthState.controls.lfoToggle.checked = SynthState.lfoEnabled;
                SynthState.controls.noiseToggle.checked = SynthState.noiseEnabled;

                document.getElementById('incrementRange').addEventListener('click', () => this.incrementPitchBendRange());
                document.getElementById('decrementRange').addEventListener('click', () => this.decrementPitchBendRange());

                // Ensure pitchBendRange is not null before using its value
                if (SynthState.controls.pitchBendRange === null) {
                    console.error('pitchBendRange element not found');
                } else {
                    // Initialize pitch bend range
                    this.updatePitchBendRange(parseInt(SynthState.controls.pitchBendRange.value) || 2);
                }

                // Set initial values for controls
                this.updateMasterVolume();
                this.updateMasterReverb();
                this.updateMasterDelay();
                this.updateMasterEQ();

                UI.createPiano();
                UI.initializeEventListeners();
                this.updateVisualizer();
                this.updateParams();
            },
            updateMasterReverb() {
                const reverbAmount = parseFloat(SynthState.controls.masterReverb.value);
                const dryAmount = Math.cos(reverbAmount * 0.5 * Math.PI);
                const wetAmount = Math.sin(reverbAmount * 0.5 * Math.PI);

                this.reverbWet.gain.setTargetAtTime(wetAmount, this.audioContext.currentTime, 0.01);
                this.reverbDry.gain.setTargetAtTime(dryAmount, this.audioContext.currentTime, 0.01);
            },

            updateMasterDelay() {
                const delayAmount = parseFloat(SynthState.controls.masterDelay.value);
                const dryAmount = Math.cos(delayAmount * 0.5 * Math.PI);
                const wetAmount = Math.sin(delayAmount * 0.5 * Math.PI);

                this.delayWet.gain.setTargetAtTime(wetAmount, this.audioContext.currentTime, 0.01);
                this.delayDry.gain.setTargetAtTime(dryAmount, this.audioContext.currentTime, 0.01);

                const delayTime = 0.1 + (delayAmount * 0.9);
                this.masterDelay.delayTime.setTargetAtTime(delayTime, this.audioContext.currentTime, 0.01);

                const feedback = delayAmount * 0.7;
                this.delayFeedback.gain.setTargetAtTime(feedback, this.audioContext.currentTime, 0.01);
            },

            updateMasterEQ() {
                const lowGain = parseFloat(SynthState.controls.masterLowEQ.value);
                const midGain = parseFloat(SynthState.controls.masterMidEQ.value);
                const highGain = parseFloat(SynthState.controls.masterHighEQ.value);

                this.masterLowEQ.gain.setTargetAtTime(lowGain, this.audioContext.currentTime, 0.01);
                this.masterMidEQ.gain.setTargetAtTime(midGain, this.audioContext.currentTime, 0.01);
                this.masterHighEQ.gain.setTargetAtTime(highGain, this.audioContext.currentTime, 0.01);
            },
            updateParams(changedParam) {
                if (changedParam === 'masterReverb') {
                    this.updateMasterReverb();
                } else if (changedParam === 'masterDelay') {
                    this.updateMasterDelay();
                } else if (changedParam === 'masterLowEQ' || changedParam === 'masterMidEQ' || changedParam === 'masterHighEQ') {
                    this.updateMasterEQ();
                } else if (changedParam === 'pitchBendWheel') {
                    this.updatePitchBend(parseFloat(SynthState.controls.pitchBendWheel.value));
                } else if (changedParam === 'pitchBendRange') {
                    this.updatePitchBendRange(parseInt(SynthState.controls.pitchBendRange.value));
                } else if (changedParam === 'masterVolume') {
                    this.updateMasterVolume();
                } else if (changedParam === 'unison' || changedParam === 'detune' || changedParam === 'waveform') {
                    Object.values(SynthState.activeVoices).forEach(voice => voice.updateVoice());
                } else if (changedParam === 'filterToggle') {
                    SynthState.filterEnabled = SynthState.controls.filterToggle.checked;
                } else if (changedParam === 'noiseToggle') {
                    SynthState.noiseEnabled = SynthState.controls.noiseToggle.checked;
                } else if (changedParam === 'lfoToggle') {
                    SynthState.lfoEnabled = SynthState.controls.lfoToggle.checked;
                }

                SynthState.filterSettings.type = SynthState.controls.filterType.value;
                SynthState.filterSettings.frequency = parseFloat(SynthState.controls.filterCutoff.value);
                SynthState.filterSettings.Q = parseFloat(SynthState.controls.filterResonance.value);
                SynthState.fmEnabled = SynthState.controls.fmToggle.checked;

                Object.values(SynthState.activeVoices).forEach(voice => voice.updateVoice());

                UI.updateCircularControls();
            },

            updateMasterVolume() {
                const volume = parseFloat(SynthState.controls.masterVolume.value);
                if (this.masterGainNode) {
                    this.masterGainNode.gain.setTargetAtTime(volume, this.audioContext.currentTime, 0.01);
                }
            },

            startRecording() {
                this.recordedChunks = [];
                this.recordedNotes = [];
                this.recordingStartTime = this.audioContext.currentTime;
                const stream = this.createMediaStreamFromAudioGraph();
                this.recorder = new MediaRecorder(stream);
                this.recorder.ondataavailable = (e) => this.recordedChunks.push(e.data);
                this.recorder.start();
                document.getElementById('recordButton').disabled = true;
                document.getElementById('stopButton').disabled = false;
                document.getElementById('playButton').disabled = true;
                document.getElementById('saveButton').disabled = true;
                document.getElementById('exportWavButton').disabled = true;
            },

            stopRecording() {
                this.recorder.stop();
                document.getElementById('recordButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
                document.getElementById('playButton').disabled = false;
                document.getElementById('saveButton').disabled = false;
                document.getElementById('exportWavButton').disabled = false;
            },

            playRecording() {
                if (this.playbackAudio) {
                    this.playbackAudio.currentTime = 0;
                } else if (this.recordedChunks.length > 0) {
                    const blob = new Blob(this.recordedChunks, { type: 'audio/wav' });
                    const audioURL = URL.createObjectURL(blob);
                    this.playbackAudio = new Audio(audioURL);
                } else {
                    console.log('No recording to play');
                    return;
                }

                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }

                if (!this.playbackSource) {
                    this.playbackSource = this.audioContext.createMediaElementSource(this.playbackAudio);
                    this.playbackSource.connect(this.compressor);
                }

                this.playbackAudio.play().then(() => {
                    this.animatePlayback();
                    UI.updateVisualizer();
                }).catch(error => {
                    console.error('Error playing audio:', error);
                });
            },

            stopPlayback() {
                if (this.playbackAudio) {
                    this.playbackAudio.pause();
                    this.playbackAudio.currentTime = 0;
                }
                document.querySelectorAll('.key.active').forEach(key => key.classList.remove('active'));
            },

            updateVisualizer() {
                if (!this.analyser || !this.visualizerEnabled) return;

                const visualizer = document.getElementById('visualizer');
                visualizer.width = visualizer.offsetWidth * window.devicePixelRatio;
                visualizer.height = visualizer.offsetHeight * window.devicePixelRatio;
                visualizer.style.width = `${visualizer.offsetWidth}px`;
                visualizer.style.height = `${visualizer.offsetHeight}px`;

                const ctx = visualizer.getContext('2d');
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

                const width = visualizer.offsetWidth;
                const height = visualizer.offsetHeight;

                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                ctx.lineWidth = 2;
                ctx.strokeStyle = '#00ff9d';

                const draw = () => {
                    if (!this.visualizerEnabled) return;

                    requestAnimationFrame(draw);
                    this.analyser.getByteTimeDomainData(dataArray);

                    ctx.fillStyle = 'rgba(26, 26, 26, 0.2)';
                    ctx.fillRect(0, 0, width, height);

                    ctx.beginPath();

                    const sliceWidth = width * 1.0 / bufferLength;
                    let x = 0;

                    for (let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = v * height / 2;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }

                        x += sliceWidth;
                    }

                    ctx.lineTo(width, height / 2);
                    ctx.stroke();
                };

                draw();
            },

            toggleVisualizer() {
                this.visualizerEnabled = !this.visualizerEnabled;
                const visualizer = document.getElementById('visualizer');
                const toggleButton = document.getElementById('toggleVisualizer');

                if (this.visualizerEnabled) {
                    visualizer.style.display = 'block';
                    // Reset visualizer size
                    visualizer.width = visualizer.offsetWidth * window.devicePixelRatio;
                    visualizer.height = visualizer.offsetHeight * window.devicePixelRatio;
                    visualizer.style.width = `${visualizer.offsetWidth}px`;
                    visualizer.style.height = `${visualizer.offsetHeight}px`;
                    this.updateVisualizer();
                } else {
                    visualizer.style.display = 'none';
                }
            },

            animatePlayback() {
                const startTime = this.audioContext.currentTime;
                let lastUpdateTime = 0;
                const updateInterval = 50; // Update every 50ms

                const animate = () => {
                    if (!this.playbackAudio || this.playbackAudio.paused) {
                        document.querySelectorAll('.key.active').forEach(key => key.classList.remove('active'));
                        return;
                    }

                    const currentTime = this.audioContext.currentTime - startTime;

                    if (currentTime - lastUpdateTime >= updateInterval / 1000) {
                        this.recordedNotes.forEach(noteEvent => {
                            if (Math.abs(noteEvent.time - currentTime) < 0.05) {
                                const keyElement = document.querySelector(`.key[data-note="${noteEvent.note}"]`);
                                if (keyElement) {
                                    if (noteEvent.isNoteOn) {
                                        keyElement.classList.add('active');
                                    } else {
                                        keyElement.classList.remove('active');
                                    }
                                }
                            }
                        });

                        lastUpdateTime = currentTime;
                    }

                    requestAnimationFrame(animate);
                };

                requestAnimationFrame(animate);
            },

            saveRecording() {
                if (this.recordedChunks.length === 0) {
                    console.log('No recording to save');
                    return;
                }

                const blob = new Blob(this.recordedChunks, { type: 'audio/wav' });
                const reader = new FileReader();
                reader.onload = (event) => {
                    const audioData = event.target.result;
                    const presets = this.getPresets();
                    const data = {
                        audio: audioData,
                        presets: presets,
                        notes: this.recordedNotes
                    };
                    const json = JSON.stringify(data);
                    const jsonBlob = new Blob([json], { type: 'application/json' });

                    const saveFile = async () => {
                        try {
                            const handle = await window.showSaveFilePicker({
                                suggestedName: 'browsynth_recording.json',
                                types: [{
                                    description: 'Browsynth Recording',
                                    accept: { 'application/json': ['.json'] },
                                }],
                            });
                            const writable = await handle.createWritable();
                            await writable.write(jsonBlob);
                            await writable.close();
                            console.log('File saved successfully');
                        } catch (err) {
                            console.error('Failed to save file:', err);
                        }
                    };

                    saveFile();
                };
                reader.readAsDataURL(blob);
            },

            loadRecording() {
                const loadFile = async () => {
                    try {
                        const [handle] = await window.showOpenFilePicker({
                            types: [{
                                description: 'Browsynth Recording',
                                accept: { 'application/json': ['.json'] },
                            }],
                        });
                        const file = await handle.getFile();
                        const contents = await file.text();
                        const data = JSON.parse(contents);
                        this.setPresets(data.presets);

                        if (this.playbackAudio) {
                            this.playbackAudio.pause();
                            this.playbackAudio.currentTime = 0;
                        }
                        this.playbackAudio = new Audio(data.audio);
                        this.recordedChunks = [];
                        this.recordedNotes = data.notes || [];
                        fetch(data.audio)
                            .then(res => res.blob())
                            .then(blob => {
                                this.recordedChunks.push(blob);
                            });
                        document.getElementById('playButton').disabled = false;
                        document.getElementById('saveButton').disabled = false;
                        console.log('File loaded successfully');
                    } catch (err) {
                        console.error('Failed to load file:', err);
                    }
                };

                loadFile();
            },

            getPresets() {
                const presets = {};
                for (const [key, control] of Object.entries(SynthState.controls)) {
                    presets[key] = control.type === 'checkbox' ? control.checked : control.value;
                }
                return presets;
            },

            setPresets(presets) {
                for (const [key, value] of Object.entries(presets)) {
                    const control = SynthState.controls[key];
                    if (control) {
                        if (control.type === 'checkbox') {
                            control.checked = value;
                        } else {
                            control.value = value;
                        }
                        this.updateParams(key);
                    }
                }
            },

            createMediaStreamFromAudioGraph() {
                const dest = this.audioContext.createMediaStreamDestination();
                this.analyser.connect(dest);
                return dest.stream;
            },

            recordNoteEvent(note, isNoteOn) {
                if (this.recorder && this.recorder.state === "recording") {
                    const time = this.audioContext.currentTime - this.recordingStartTime;
                    this.recordedNotes.push({ note, time, isNoteOn });
                }
            },

            exportWav() {
                if (!this.audioContext) {
                    console.error('AudioContext is not initialized');
                    return;
                }
                if (this.recordedChunks.length === 0) {
                    console.log('No recording to export');
                    return;
                }

                const blob = new Blob(this.recordedChunks, { type: 'audio/wav' });

                blob.arrayBuffer().then(arrayBuffer => {
                    this.audioContext.decodeAudioData(arrayBuffer, (audioBuffer) => {
                        const offlineCtx = new OfflineAudioContext(audioBuffer.numberOfChannels, audioBuffer.duration * 22050, 22050);
                        const source = offlineCtx.createBufferSource();
                        source.buffer = audioBuffer;
                        source.connect(offlineCtx.destination);
                        source.start();

                        offlineCtx.startRendering().then(renderedBuffer => {
                            const wav = this.audioBufferToWav(renderedBuffer);
                            const wavBlob = new Blob([new DataView(wav)], { type: 'audio/wav' });

                            const url = URL.createObjectURL(wavBlob);
                            const a = document.createElement('a');
                            document.body.appendChild(a);
                            a.style = 'display: none';
                            a.href = url;
                            a.download = 'browsynth_recording.wav';
                            a.click();
                            window.URL.revokeObjectURL(url);
                        }).catch(err => {
                            console.error('Error rendering audio:', err);
                        });
                    }, (err) => {
                        console.error('Error decoding audio data:', err);
                    });
                }).catch(err => {
                    console.error('Error reading blob:', err);
                });
            },

            audioBufferToWav(buffer) {
                const numChannels = buffer.numberOfChannels;
                const sampleRate = 22050;
                const format = 1;
                const bitDepth = 16;

                let result = new ArrayBuffer(44 + buffer.length * numChannels * 2);
                let view = new DataView(result);

                this.writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + buffer.length * numChannels * 2, true);
                this.writeString(view, 8, 'WAVE');
                this.writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, format, true);
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * numChannels * 2, true);
                view.setUint16(32, numChannels * 2, true);
                view.setUint16(34, bitDepth, true);
                this.writeString(view, 36, 'data');
                view.setUint32(40, buffer.length * numChannels * 2, true);

                const length = buffer.length;
                const channels = buffer.numberOfChannels;
                let offset = 44;
                for (let i = 0; i < length; i++) {
                    for (let channel = 0; channel < channels; channel++) {
                        let sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                        view.setInt16(offset, sample, true);
                        offset += 2;
                    }
                }

                return result;
            },

            writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            },
        };

        // Initialize the synth when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => Synth.initialize());
    </script>
</body>

</html>