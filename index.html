<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PianoSynth</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        #synth-container {
            background-color: #2a2a2a;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #00ff9d;
            margin-bottom: 20px;
        }

        #controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            background-color: #333;
            border-radius: 5px;
            padding: 15px;
        }

        .control-group h2 {
            font-size: 18px;
            margin-top: 0;
            margin-bottom: 15px;
            color: #00ff9d;
        }

        .control {
            margin-bottom: 20px;
            text-align: center;
        }

        .control label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            text-transform: uppercase;
        }

        .circular-control {
            width: 80px;
            height: 80px;
            margin: 0 auto;
            background-color: #4a4a4a;
            border-radius: 50%;
            position: relative;
            cursor: pointer;
        }

        .circular-control::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70px;
            height: 70px;
            background-color: #2a2a2a;
            border-radius: 50%;
        }

        .circular-control::after {
            content: '';
            position: absolute;
            top: 10%;
            left: 50%;
            width: 4px;
            height: 40%;
            background-color: #00ff9d;
            transform-origin: bottom;
            transform: translateX(-50%) rotate(var(--rotation, 0deg));
        }

        .circular-control input[type="range"] {
            display: none;
        }

        select {
            width: 100%;
            padding: 5px;
            background-color: #4a4a4a;
            color: #e0e0e0;
            border: none;
            border-radius: 5px;
        }

        #piano {
            display: flex;
            background-color: #333;
            padding: 10px;
            border-radius: 10px;
            overflow-x: auto;
            margin-bottom: 20px;
        }

        .key {
            width: 30px;
            height: 120px;
            background-color: white;
            border: 1px solid #000;
            margin: 0 1px;
            cursor: pointer;
        }

        .key.black {
            width: 20px;
            height: 80px;
            background-color: black;
            margin: 0 -10px;
            z-index: 1;
            position: relative;
        }

        .key.active {
            background-color: #00ff9d;
        }

        #visualizer {
            width: 100%;
            height: 100px;
            border: 1px solid #4a4a4a;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <div id="synth-container">
        <h1>Advanced PianoSynth</h1>
        <div id="piano"></div>
        <canvas id="visualizer"></canvas>
        <div id="controls">
            <div class="control-group">
                <h2>Oscillator</h2>
                <div class="control">
                    <label for="waveform">Waveform</label>
                    <select id="waveform">
                        <option value="sine">Sine</option>
                        <option value="square">Square</option>
                        <option value="sawtooth">Sawtooth</option>
                        <option value="triangle">Triangle</option>
                    </select>
                </div>
                <div class="control">
                    <label for="unison">Unison</label>
                    <div class="circular-control">
                        <input type="range" id="unison" min="1" max="8" step="1" value="1">
                    </div>
                </div>
                <div class="control">
                    <label for="detune">Detune</label>
                    <div class="circular-control">
                        <input type="range" id="detune" min="0" max="100" step="1" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="fmAmount">FM Amount</label>
                    <div class="circular-control">
                        <input type="range" id="fmAmount" min="0" max="1000" step="1" value="0">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Filter</h2>
                <div class="control">
                    <label for="filterType">Filter Type</label>
                    <select id="filterType">
                        <option value="lowpass">Lowpass</option>
                        <option value="highpass">Highpass</option>
                        <option value="bandpass">Bandpass</option>
                    </select>
                </div>
                <div class="control">
                    <label for="filterCutoff">Cutoff</label>
                    <div class="circular-control">
                        <input type="range" id="filterCutoff" min="20" max="20000" step="1" value="20000">
                    </div>
                </div>
                <div class="control">
                    <label for="filterResonance">Resonance</label>
                    <div class="circular-control">
                        <input type="range" id="filterResonance" min="0" max="20" step="0.1" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="filterEnvAmount">Env Amount</label>
                    <div class="circular-control">
                        <input type="range" id="filterEnvAmount" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Envelope</h2>
                <div class="control">
                    <label for="attack">Attack</label>
                    <div class="circular-control">
                        <input type="range" id="attack" min="0" max="2" step="0.01" value="0.05">
                    </div>
                </div>
                <div class="control">
                    <label for="decay">Decay</label>
                    <div class="circular-control">
                        <input type="range" id="decay" min="0" max="2" step="0.01" value="0.1">
                    </div>
                </div>
                <div class="control">
                    <label for="sustain">Sustain</label>
                    <div class="circular-control">
                        <input type="range" id="sustain" min="0" max="1" step="0.01" value="0.5">
                    </div>
                </div>
                <div class="control">
                    <label for="release">Release</label>
                    <div class="circular-control">
                        <input type="range" id="release" min="0" max="5" step="0.01" value="0.5">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>LFO</h2>
                <div class="control">
                    <label for="lfoRate">Rate</label>
                    <div class="circular-control">
                        <input type="range" id="lfoRate" min="0" max="20" step="0.1" value="0">
                    </div>
                </div>
                <div class="control">
                    <label for="lfoAmount">Amount</label>
                    <div class="circular-control">
                        <input type="range" id="lfoAmount" min="0" max="1000" step="1" value="50">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Noise</h2>
                <div class="control">
                    <label for="noiseAmount">Amount</label>
                    <div class="circular-control">
                        <input type="range" id="noiseAmount" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Arpeggiator</h2>
                <div class="control">
                    <label for="arpToggle">Arp On/Off</label>
                    <input type="checkbox" id="arpToggle">
                </div>
                <div class="control">
                    <label for="arpPattern">Pattern</label>
                    <select id="arpPattern">
                        <option value="up">Up</option>
                        <option value="down">Down</option>
                        <option value="upDown">Up-Down</option>
                        <option value="random">Random</option>
                        <option value="trance">Trance</option>
                    </select>
                </div>
                <div class="control">
                    <label for="arpSpeed">Speed (ms)</label>
                    <div class="circular-control">
                        <input type="range" id="arpSpeed" min="50" max="500" step="10" value="200">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const masterGainNode = audioContext.createGain();
        masterGainNode.connect(audioContext.destination);

        const controls = {
            waveform: document.getElementById('waveform'),
            unison: document.getElementById('unison'),
            detune: document.getElementById('detune'),
            fmAmount: document.getElementById('fmAmount'),
            filterType: document.getElementById('filterType'),
            filterCutoff: document.getElementById('filterCutoff'),
            filterResonance: document.getElementById('filterResonance'),
            filterEnvAmount: document.getElementById('filterEnvAmount'),
            attack: document.getElementById('attack'),
            decay: document.getElementById('decay'),
            sustain: document.getElementById('sustain'),
            release: document.getElementById('release'),
            lfoRate: document.getElementById('lfoRate'),
            lfoAmount: document.getElementById('lfoAmount'),
            noiseAmount: document.getElementById('noiseAmount'),
            arpToggle: document.getElementById('arpToggle'),
            arpPattern: document.getElementById('arpPattern'),
            arpSpeed: document.getElementById('arpSpeed')
        };

        const visualizer = document.getElementById('visualizer');
        const visualizerContext = visualizer.getContext('2d');

        let activeVoices = {};
        let activeNotes = new Set();

        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const whiteNotes = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
        const blackNotes = ['C#', 'D#', 'F#', 'G#', 'A#'];

        const keyboardMap = {
            'q': 'C4', 'w': 'D4', 'e': 'E4', 'r': 'F4', 't': 'G4', 'y': 'A4', 'u': 'B4', 'ı': 'C5', 'o': 'D5', 'p': 'E5', 'ğ': 'F5', 'ü': 'G5',
            'a': 'C#4', 's': 'D#4', 'f': 'F#4', 'g': 'G#4', 'h': 'A#4', 'j': 'C#5', 'k': 'D#5', 'l': 'F#5', 'ş': 'G#5', 'i': 'A#5',
            'z': 'C3', 'x': 'D3', 'c': 'E3', 'v': 'F3', 'b': 'G3', 'n': 'A3', 'm': 'B3', 'ö': 'C4', 'ç': 'D4', '.': 'E4'
        };

        const arpeggiator = {
            isOn: false,
            pattern: 'up',
            speed: 200,
            notes: [],
            currentIndex: 0,
            intervalId: null,

            start() {
                if (this.notes.length === 0) return;
                this.stop();
                this.playCurrentNote();
                this.intervalId = setInterval(() => this.playNextNote(), this.speed);
            },

            stop() {
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                }
                stopAllNotes();
            },

            addNote(note) {
                if (!this.notes.includes(note)) {
                    this.notes.push(note);
                    this.notes.sort((a, b) => noteToFreq(a) - noteToFreq(b));
                }
                if (this.notes.length === 1) {
                    this.start();
                }
            },

            removeNote(note) {
                const index = this.notes.indexOf(note);
                if (index > -1) {
                    this.notes.splice(index, 1);
                }
                if (this.notes.length === 0) {
                    this.stop();
                }
            },

            playNextNote() {
                this.currentIndex = this.getNextIndex();
                this.playCurrentNote();
            },

            playCurrentNote() {
                if (this.notes.length === 0) return;
                const note = this.notes[this.currentIndex];
                stopAllNotes();
                playNote(note, true);
            },

            getNextIndex() {
                switch (this.pattern) {
                    case 'up':
                        return (this.currentIndex + 1) % this.notes.length;
                    case 'down':
                        return (this.currentIndex - 1 + this.notes.length) % this.notes.length;
                    case 'upDown':
                        if (this.currentIndex === 0) {
                            this.direction = 1;
                        } else if (this.currentIndex === this.notes.length - 1) {
                            this.direction = -1;
                        }
                        return this.currentIndex + this.direction;
                    case 'random':
                        return Math.floor(Math.random() * this.notes.length);
                    case 'trance':
                        // Trance pattern: play the root note, then a higher note, then back to root
                        if (!this.tranceStep) this.tranceStep = 0;
                        this.tranceStep = (this.tranceStep + 1) % 3;
                        if (this.tranceStep === 0) {
                            return 0; // Root note
                        } else if (this.tranceStep === 1) {
                            return Math.min(2, this.notes.length - 1); // Third note or highest available
                        } else {
                            return 0; // Back to root
                        }
                }
            },
        };

        function createPiano() {
            const piano = document.getElementById('piano');
            piano.innerHTML = '';
            for (let octave = 1; octave < 7; octave++) {
                whiteNotes.forEach(note => {
                    const key = document.createElement('div');
                    key.className = 'key';
                    key.dataset.note = note + octave;
                    piano.appendChild(key);
                });
            }

            const whiteKeys = piano.querySelectorAll('.key');
            let blackKeyIndex = 0;
            whiteKeys.forEach((whiteKey, index) => {
                if (index % 7 !== 2 && index % 7 !== 6) {
                    const blackKey = document.createElement('div');
                    blackKey.className = 'key black';
                    blackKey.dataset.note = blackNotes[blackKeyIndex % 5] + (Math.floor(index / 7) + 1);
                    whiteKey.parentNode.insertBefore(blackKey, whiteKey.nextSibling);
                    blackKeyIndex++;
                }
            });
        }

        function updateVisualizer() {
            const width = visualizer.offsetWidth;
            const height = visualizer.offsetHeight;
            visualizerContext.clearRect(0, 0, width, height);

            visualizerContext.fillStyle = '#00ff9d';
            visualizerContext.strokeStyle = '#00ff9d';
            visualizerContext.lineWidth = 2;

            // Draw oscillator waveform
            visualizerContext.beginPath();
            const waveform = controls.waveform.value;
            for (let x = 0; x < width; x++) {
                const t = x / width;
                let y;
                switch (waveform) {
                    case 'sine':
                        y = Math.sin(2 * Math.PI * t);
                        break;
                    case 'square':
                        y = t < 0.5 ? 1 : -1;
                        break;
                    case 'sawtooth':
                        y = 2 * (t - Math.floor(t + 0.5));
                        break;
                    case 'triangle':
                        y = 1 - 4 * Math.abs(Math.round(t) - t);
                        break;
                }
                y = (y * 0.5 + 0.5) * height;
                visualizerContext.lineTo(x, y);
            }
            visualizerContext.stroke();

            // Draw filter response
            const filterFreq = controls.filterCutoff.value;
            const normalizedFreq = Math.log(filterFreq / 20) / Math.log(1000);
            const filterX = normalizedFreq * width;
            visualizerContext.beginPath();
            visualizerContext.moveTo(0, height);
            visualizerContext.lineTo(filterX, 0);
            visualizerContext.lineTo(width, 0);
            visualizerContext.globalAlpha = 0.2;
            visualizerContext.fill();
            visualizerContext.globalAlpha = 1;

            // Draw envelope
            const attackTime = parseFloat(controls.attack.value);
            const decayTime = parseFloat(controls.decay.value);
            const sustainLevel = parseFloat(controls.sustain.value);
            const releaseTime = parseFloat(controls.release.value);

            const totalTime = attackTime + decayTime + releaseTime;
            const scaleX = width / totalTime;

            visualizerContext.beginPath();
            visualizerContext.moveTo(0, height);
            visualizerContext.lineTo(attackTime * scaleX, 0);
            visualizerContext.lineTo((attackTime + decayTime) * scaleX, (1 - sustainLevel) * height);
            visualizerContext.lineTo(width - releaseTime * scaleX, (1 - sustainLevel) * height);
            visualizerContext.lineTo(width, height);
            visualizerContext.stroke();
        }

        function playNote(note, isArpeggiator = false) {
            if (!note) {
                console.error('Invalid note:', note);
                return;
            }

            if (!isArpeggiator && arpeggiator.isOn) {
                arpeggiator.addNote(note);
                return;
            }

            if (activeVoices[note]) {
                return;
            }

            const frequency = noteToFreq(note);
            if (frequency === 0) {
                console.error('Failed to get frequency for note:', note);
                return;
            }

            const now = audioContext.currentTime;

            // Create multiple oscillators for unison
            const unisonCount = parseInt(controls.unison.value) || 1;
            const detune = parseFloat(controls.detune.value) || 0;
            const oscillators = [];

            for (let i = 0; i < unisonCount; i++) {
                const osc = audioContext.createOscillator();
                osc.type = controls.waveform.value;
                osc.frequency.setValueAtTime(frequency, now);

                // Detune each oscillator
                let detuneAmount = 0;
                if (unisonCount > 1) {
                    detuneAmount = (i / (unisonCount - 1) - 0.5) * detune;
                }
                osc.detune.setValueAtTime(detuneAmount, now);

                oscillators.push(osc);
            }

            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0, now);

            const filter = audioContext.createBiquadFilter();
            filter.type = controls.filterType.value;
            filter.frequency.setValueAtTime(controls.filterCutoff.value, now);
            filter.Q.setValueAtTime(controls.filterResonance.value, now);

            // FM Modulation
            const fmOsc = audioContext.createOscillator();
            fmOsc.frequency.setValueAtTime(frequency * 2, now);
            const fmGain = audioContext.createGain();
            const fmAmount = parseFloat(controls.fmAmount.value) || 0;
            fmGain.gain.setValueAtTime(fmAmount, now);
            fmOsc.connect(fmGain);
            fmGain.connect(filter.frequency);
            fmOsc.start(now);

            // Noise oscillator
            const noiseOsc = audioContext.createBufferSource();
            const noiseBuffer = audioContext.createBuffer(1, 44100, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = Math.random() * 2 - 1;
            }
            noiseOsc.buffer = noiseBuffer;
            noiseOsc.loop = true;
            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(parseFloat(controls.noiseAmount.value) || 0, now);
            noiseOsc.connect(noiseGain);
            noiseGain.connect(filter);
            noiseOsc.start(now);

            oscillators.forEach(osc => osc.connect(filter));
            filter.connect(gainNode);
            gainNode.connect(masterGainNode);

            const attackTime = parseFloat(controls.attack.value);
            const decayTime = parseFloat(controls.decay.value);
            const sustainLevel = parseFloat(controls.sustain.value);

            const peakLevel = 0.66 / Math.max(1, Math.sqrt(activeNotes.size));
            const sustainedLevel = sustainLevel * peakLevel;

            gainNode.gain.linearRampToValueAtTime(peakLevel, now + attackTime);
            gainNode.gain.linearRampToValueAtTime(sustainedLevel, now + attackTime + decayTime);

            // Filter envelope
            const filterEnvAmount = parseFloat(controls.filterEnvAmount.value);
            const filterStartFreq = filter.frequency.value;
            const filterPeakFreq = Math.min(filterStartFreq * (1 + filterEnvAmount * 10), audioContext.sampleRate / 2);
            filter.frequency.linearRampToValueAtTime(filterPeakFreq, now + attackTime);
            filter.frequency.linearRampToValueAtTime(filterStartFreq, now + attackTime + decayTime);

            oscillators.forEach(osc => osc.start(now));

            // LFO
            const lfo = audioContext.createOscillator();
            const lfoGain = audioContext.createGain();
            lfo.frequency.setValueAtTime(parseFloat(controls.lfoRate.value), now);
            lfoGain.gain.setValueAtTime(parseFloat(controls.lfoAmount.value) || 0, now);
            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);
            lfo.start(now);

            const voice = { oscillators, gainNode, filter, fmOsc, fmGain, noiseOsc, noiseGain, lfo, lfoGain };

            activeVoices[note] = voice;
            activeNotes.add(note);

            const keyElement = document.querySelector(`.key[data-note="${note}"]`);
            if (keyElement) {
                keyElement.classList.add('active');
            }
        }

        function releaseVoice(voice) {
            const now = audioContext.currentTime;
            const releaseTime = parseFloat(controls.release.value);

            voice.gainNode.gain.cancelScheduledValues(now);
            voice.gainNode.gain.setValueAtTime(voice.gainNode.gain.value, now);
            voice.gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);

            setTimeout(() => {
                voice.oscillators.forEach(osc => {
                    osc.stop();
                    osc.disconnect();
                });
                voice.gainNode.disconnect();
                voice.filter.disconnect();
                voice.fmOsc.stop();
                voice.fmOsc.disconnect();
                voice.fmGain.disconnect();
                voice.noiseOsc.stop();
                voice.noiseOsc.disconnect();
                voice.noiseGain.disconnect();
                voice.lfo.stop();
                voice.lfo.disconnect();
                voice.lfoGain.disconnect();
            }, releaseTime * 1000);
        }

        function stopNote(note) {
            if (arpeggiator.isOn) {
                arpeggiator.removeNote(note);
                return;
            }

            if (activeVoices[note]) {
                releaseVoice(activeVoices[note]);
                delete activeVoices[note];
                activeNotes.delete(note);

                const keyElement = document.querySelector(`.key[data-note="${note}"]`);
                if (keyElement) {
                    keyElement.classList.remove('active');
                }
            }
        }

        function noteToFreq(note) {
            if (!note) {
                console.error('Invalid note:', note);
                return 0; // Return a default frequency or handle the error as appropriate
            }

            let noteName, octave;

            if (note.length > 1 && !isNaN(note[note.length - 1])) {
                // If the last character is a number (octave)
                noteName = note.slice(0, -1);
                octave = parseInt(note.slice(-1));
            } else {
                // If there's no octave specified, assume it's in the 4th octave
                noteName = note;
                octave = 4;
            }

            const noteIndex = notes.indexOf(noteName);
            if (noteIndex === -1) {
                console.error('Invalid note name:', noteName);
                return 0; // Return a default frequency or handle the error as appropriate
            }

            return 440 * Math.pow(2, (noteIndex - 9) / 12 + (octave - 4));
        }
        function drawVisualizer() {
            const width = visualizer.offsetWidth;
            const height = visualizer.offsetHeight;
            visualizer.width = width;
            visualizer.height = height;

            const analyser = audioContext.createAnalyser();
            masterGainNode.connect(analyser);

            analyser.fftSize = 2048;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            visualizerContext.clearRect(0, 0, width, height);

            function draw() {
                requestAnimationFrame(draw);
                analyser.getByteTimeDomainData(dataArray);

                visualizerContext.fillStyle = 'rgb(26, 26, 26)';
                visualizerContext.fillRect(0, 0, width, height);

                visualizerContext.lineWidth = 2;
                visualizerContext.strokeStyle = '#00ff9d';
                visualizerContext.beginPath();

                const sliceWidth = width * 1.0 / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * height / 2;

                    if (i === 0) {
                        visualizerContext.moveTo(x, y);
                    } else {
                        visualizerContext.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                visualizerContext.lineTo(width, height / 2);
                visualizerContext.stroke();
            }

            draw();
        }

        function stopAllNotes() {
            activeNotes.forEach(note => {
                if (activeVoices[note]) {
                    releaseVoice(activeVoices[note]);
                    delete activeVoices[note];
                }
            });
            activeNotes.clear();

            const keys = document.querySelectorAll('.key.active');
            keys.forEach(key => key.classList.remove('active'));
        }

        function updateSynthParams() {
            Object.values(activeVoices).forEach(voice => {
                const now = audioContext.currentTime;
                voice.filter.type = controls.filterType.value;
                voice.filter.frequency.setValueAtTime(parseFloat(controls.filterCutoff.value), now);
                voice.filter.Q.setValueAtTime(parseFloat(controls.filterResonance.value), now);
                voice.fmGain.gain.setValueAtTime(parseFloat(controls.fmAmount.value) || 0, now);
                voice.lfo.frequency.setValueAtTime(parseFloat(controls.lfoRate.value) || 0, now);
                voice.noiseGain.gain.setValueAtTime(parseFloat(controls.noiseAmount.value) || 0, now);
                voice.lfoGain.gain.setValueAtTime(parseFloat(controls.lfoAmount.value) || 0, now);

                // Update unison and detune
                const unisonCount = parseInt(controls.unison.value) || 1;
                const detune = parseFloat(controls.detune.value) || 0;

                // If the number of oscillators has changed, we need to create or remove oscillators
                while (voice.oscillators.length < unisonCount) {
                    const newOsc = audioContext.createOscillator();
                    newOsc.type = controls.waveform.value;
                    newOsc.frequency.setValueAtTime(voice.oscillators[0].frequency.value, now);
                    newOsc.connect(voice.filter);
                    newOsc.start(now);
                    voice.oscillators.push(newOsc);
                }
                while (voice.oscillators.length > unisonCount) {
                    const oscToRemove = voice.oscillators.pop();
                    oscToRemove.stop(now);
                    oscToRemove.disconnect();
                }

                // Update detune for each oscillator
                voice.oscillators.forEach((osc, i) => {
                    osc.type = controls.waveform.value;
                    let detuneAmount = 0;
                    if (unisonCount > 1) {
                        detuneAmount = (i / (unisonCount - 1) - 0.5) * detune;
                    }
                    osc.detune.setValueAtTime(detuneAmount, now);
                });
            });

            // Update circular control display
            document.querySelectorAll('.circular-control input[type="range"]').forEach(input => {
                const value = parseFloat(input.value);
                const min = parseFloat(input.min);
                const max = parseFloat(input.max);
                const normalizedValue = (value - min) / (max - min);
                const rotation = normalizedValue * 270 - 135; // Map 0-1 to -135deg to 135deg
                input.parentNode.style.setProperty('--rotation', `${rotation}deg`);
            });
        }

        function handleCircularControlInteraction(event) {
            const control = event.currentTarget;
            const input = control.querySelector('input[type="range"]');
            let startY = event.clientY;
            let startValue = parseFloat(input.value);

            function handleMouseMove(e) {
                const deltaY = startY - e.clientY;
                const range = input.max - input.min;
                const valueChange = (deltaY / 100) * range;
                let newValue = startValue + valueChange;
                newValue = Math.max(input.min, Math.min(input.max, newValue));

                input.value = newValue;
                updateSynthParams();
                input.dispatchEvent(new Event('change'));
                e.preventDefault();
            }

            function handleMouseUp() {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            }

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }

        function initializeSynth() {
            createPiano();
            drawVisualizer();

            const keys = document.querySelectorAll('.key');
            keys.forEach(key => {
                key.addEventListener('mousedown', () => {
                    const note = key.dataset.note;
                    playNote(note);
                });
                key.addEventListener('mouseup', () => stopNote(key.dataset.note));
                key.addEventListener('mouseleave', () => stopNote(key.dataset.note));
            });

            // Arpeggiator controls
            controls.arpToggle.addEventListener('change', (e) => {
                arpeggiator.isOn = e.target.checked;
                if (arpeggiator.isOn) {
                    arpeggiator.start();
                } else {
                    arpeggiator.stop();
                    stopAllNotes();
                }
            });

            controls.arpPattern.addEventListener('change', (e) => {
                arpeggiator.pattern = e.target.value;
            });

            controls.arpSpeed.addEventListener('input', (e) => {
                arpeggiator.speed = parseInt(e.target.value);
                if (arpeggiator.isOn) {
                    arpeggiator.stop();
                    arpeggiator.start();
                }
            });

            // Keyboard controls
            document.addEventListener('keydown', (event) => {
                const note = keyboardMap[event.key.toLowerCase()];
                if (note && !event.repeat) {
                    playNote(note);
                }
            });

            document.addEventListener('keyup', (event) => {
                const note = keyboardMap[event.key.toLowerCase()];
                if (note) {
                    stopNote(note);
                }
            });

            // Window blur event
            window.addEventListener('blur', () => {
                activeNotes.forEach(stopNote);
            });

            // Window resize event
            window.addEventListener('resize', drawVisualizer);

            // Add event listeners for all controls
            Object.values(controls).forEach(control => {
                control.addEventListener('input', updateSynthParams);
                control.addEventListener('change', updateVisualizer);
            });

            // Add event listeners for circular controls
            document.querySelectorAll('.circular-control').forEach(control => {
                control.addEventListener('mousedown', handleCircularControlInteraction);
            });

            // Initialize audio context on user interaction
            document.addEventListener('click', function initAudio() {
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                document.removeEventListener('click', initAudio);
            });

            // Initial update of circular controls
            updateSynthParams();
        }

        // Initialize the synth when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', initializeSynth);
    </script>
</body>

</html>