<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <title>Browsynth</title>
</head>

<body>
    <div id="startModal" class="modal">
        <div class="modal-content">
            <h2>Welcome to Browsynth</h2>
            <p>Click the button below to start the synthesizer.</p>
            <p>Use your keyboard to play notes.</p>
            <p>Currently not supported on mobile devices.</p>
            <button id="startButton">Let's Browsynth!</button>
        </div>
    </div>

    <!-- Wavetable Editor Modal -->
    <div id="wavetableModal" class="modal" style="display: none;">
        <div class="wavetable-modal-content">
            <div class="wavetable-header">
                <h2>Wavetable Editor</h2>
                <button id="closeWavetableEditor" class="close-btn"><i class="fas fa-times"></i></button>
            </div>
            <div class="wavetable-main">
                <div class="wavetable-3d-container">
                    <canvas id="wavetable3D"></canvas>
                    <div class="wavetable-3d-controls">
                        <label>Rotate: <input type="range" id="wt3dRotateX" min="-90" max="90" value="-30"></label>
                        <label>Zoom: <input type="range" id="wt3dZoom" min="0.5" max="3" step="0.1" value="1.5"></label>
                    </div>
                </div>
                <div class="wavetable-2d-container">
                    <div class="wavetable-2d-header">
                        <span>Frame: <span id="currentFrameNum">1</span> / <span id="totalFrames">8</span></span>
                        <div class="frame-nav">
                            <button id="prevFrame" class="frame-btn"><i class="fas fa-chevron-left"></i></button>
                            <button id="nextFrame" class="frame-btn"><i class="fas fa-chevron-right"></i></button>
                            <button id="addFrame" class="frame-btn" title="Add Frame"><i class="fas fa-plus"></i></button>
                            <button id="deleteFrame" class="frame-btn" title="Delete Frame"><i class="fas fa-trash"></i></button>
                        </div>
                    </div>
                    <canvas id="wavetable2D"></canvas>
                    <div class="wavetable-tools">
                        <button id="toolDraw" class="tool-btn active" title="Draw"><i class="fas fa-pencil-alt"></i></button>
                        <button id="toolLine" class="tool-btn" title="Line"><i class="fas fa-minus"></i></button>
                        <button id="toolSmooth" class="tool-btn" title="Smooth"><i class="fas fa-water"></i></button>
                        <button id="toolNormalize" class="tool-btn" title="Normalize"><i class="fas fa-expand-arrows-alt"></i></button>
                        <span class="tool-separator"></span>
                        <select id="presetWaveform">
                            <option value="">Load Shape...</option>
                            <option value="sine">Sine</option>
                            <option value="triangle">Triangle</option>
                            <option value="sawtooth">Sawtooth</option>
                            <option value="square">Square</option>
                            <option value="pulse25">Pulse 25%</option>
                            <option value="pulse10">Pulse 10%</option>
                            <option value="random">Random</option>
                            <option value="clear">Clear</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="wavetable-footer">
                <select id="wavetablePresets">
                    <option value="">Load Wavetable...</option>
                    <option value="basic">Basic Shapes</option>
                    <option value="pwm">PWM Sweep</option>
                    <option value="formant">Formant</option>
                    <option value="digital">Digital</option>
                    <option value="analog">Analog</option>
                    <option value="vocal">Vocal</option>
                </select>
                <button id="applyWavetable" class="apply-btn">Apply</button>
            </div>
        </div>
    </div>
    <div id="synth-container">
        <h1>Browsynth</h1>
        <div id="synth-content">
            <div id="piano-and-pitch-bend">
                <div id="piano"></div>
                <div class="pitch-bend-container">
                    <div class="control">
                        <label for="pitchBendWheel">Pitch</label>
                        <div class="vertical-slider-container">
                            <input type="range" id="pitchBendWheel" min="-1" max="1" step="0.01" value="0"
                                class="vertical-slider">
                        </div>
                    </div>
                    <div class="control">
                        <label for="pitchBendRange">Range</label>
                        <div class="range-control">
                            <button id="incrementRange" class="range-button">+</button>
                            <div class="range-value-container">
                                <input type="number" id="pitchBendRange" min="1" max="24" value="2" class="hidden-input"
                                    readonly>
                            </div>
                            <button id="decrementRange" class="range-button">-</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <canvas id="visualizer"></canvas>
        <div id="recorder-controls">
            <button id="recordButton" class="control-button" title="Record">
                <i class="fas fa-microphone"></i>
            </button>
            <button id="stopButton" class="control-button" disabled title="Stop">
                <i class="fas fa-stop"></i>
            </button>
            <button id="playButton" class="control-button" disabled title="Play">
                <i class="fas fa-play"></i>
            </button>
            <button id="saveButton" class="control-button" disabled title="Save">
                <i class="fas fa-save"></i>
            </button>
            <button id="exportWavButton" class="control-button" disabled title="Export WAV">
                <i class="fas fa-file-export"></i>
            </button>
            <button id="loadButton" class="control-button" title="Load">
                <i class="fas fa-folder-open"></i>
            </button>
            <button id="toggleVisualizer" class="control-button" title="Show/Hide Visualizer">
                <i class="fa-solid fa-wave-square"></i>
            </button>
            <select id="visualizerMode" title="Visualizer Mode">
                <option value="lissajous">Lissajous</option>
                <option value="oscilloscope">Oscilloscope</option>
            </select>
            <span class="control-separator"></span>
            <select id="presetSelect" title="Load Preset">
                <option value="">-- Presets --</option>
            </select>
            <button id="savePresetButton" class="control-button" title="Save Preset">
                <i class="fas fa-plus"></i>
            </button>
            <button id="deletePresetButton" class="control-button" title="Delete Preset">
                <i class="fas fa-trash"></i>
            </button>
            <span class="control-separator"></span>
            <button id="midiEnableButton" class="control-button" title="Enable MIDI Input">
                <i class="fas fa-plug"></i>
            </button>
        </div>
        <div id="controls">
            <div class="control-group">
                <h2>Master</h2>
                <div class="control">
                    <label for="masterVolume">Volume</label>
                    <div class="circular-control" data-unit="%">
                        <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.7">
                        <span class="knob-value">70%</span>
                    </div>
                </div>
                <div class="control">
                    <label for="masterReverb">Reverb</label>
                    <div class="circular-control" data-unit="%">
                        <input type="range" id="masterReverb" min="0" max="1" step="0.01" value="0">
                        <span class="knob-value">0%</span>
                    </div>
                </div>
                <div class="control">
                    <label for="masterDelay">Delay</label>
                    <div class="circular-control" data-unit="%">
                        <input type="range" id="masterDelay" min="0" max="1" step="0.01" value="0">
                        <span class="knob-value">0%</span>
                    </div>
                </div>
            </div>
            <div class="control-group eq-group">
                <h2>EQ</h2>
                <div class="eq-controls">
                    <div class="eq-control">
                        <label for="masterLowEQ">Low</label>
                        <input type="range" id="masterLowEQ" min="-12" max="12" step="0.1" value="0" class="eq-slider">
                    </div>
                    <div class="eq-control">
                        <label for="masterMidEQ">Mid</label>
                        <input type="range" id="masterMidEQ" min="-12" max="12" step="0.1" value="0" class="eq-slider">
                    </div>
                    <div class="eq-control">
                        <label for="masterHighEQ">High</label>
                        <input type="range" id="masterHighEQ" min="-12" max="12" step="0.1" value="0" class="eq-slider">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Oscillator</h2>
                <div class="control">
                    <label for="synthMode">Mode</label>
                    <select id="synthMode">
                        <option value="waveform">Waveform</option>
                        <option value="wavetable">Wavetable</option>
                        <option value="piano">Toy Piano</option>
                    </select>
                </div>
                <div class="control" id="waveformControl">
                    <label for="waveform">Waveform</label>
                    <select id="waveform">
                        <option value="sine">Sine</option>
                        <option value="square">Square</option>
                        <option value="sawtooth">Sawtooth</option>
                        <option value="triangle">Triangle</option>
                    </select>
                </div>
                <div class="control" id="wavetableControls" style="display: none;">
                    <label>Wavetable</label>
                    <button id="openWavetableEditor" class="wavetable-edit-btn">
                        <i class="fas fa-wave-square"></i> Edit
                    </button>
                    <div class="control" style="margin-top: 10px;">
                        <label for="wavetablePosition">Position</label>
                        <div class="circular-control" data-unit="%">
                            <input type="range" id="wavetablePosition" min="0" max="1" step="0.001" value="0">
                            <span class="knob-value">0%</span>
                        </div>
                    </div>
                </div>
                <div class="control">
                    <label for="unison">Unison</label>
                    <div class="circular-control" data-unit="x">
                        <input type="range" id="unison" min="1" max="8" step="1" value="1">
                        <span class="knob-value">1x</span>
                    </div>
                </div>
                <div class="control">
                    <label for="detune">Detune</label>
                    <div class="circular-control" data-unit="ct">
                        <input type="range" id="detune" min="0" max="100" step="1" value="0">
                        <span class="knob-value">0ct</span>
                    </div>
                </div>
                <div class="control">
                    <label for="fmToggle">FM On/Off</label>
                    <input type="checkbox" id="fmToggle">
                </div>
                <div class="control">
                    <label for="fmAmount">FM Amount</label>
                    <div class="circular-control" data-unit="">
                        <input type="range" id="fmAmount" min="0" max="1000" step="1" value="0">
                        <span class="knob-value">0</span>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Filter</h2>
                <div class="control">
                    <label for="filterToggle">Filter On/Off</label>
                    <input type="checkbox" id="filterToggle" checked>
                </div>
                <div class="control">
                    <label for="filterType">Filter Type</label>
                    <select id="filterType">
                        <option value="lowpass">Lowpass</option>
                        <option value="highpass">Highpass</option>
                        <option value="bandpass">Bandpass</option>
                    </select>
                </div>
                <div class="control">
                    <label for="filterCutoff">Cutoff</label>
                    <div class="circular-control" data-unit="Hz" data-format="freq">
                        <input type="range" id="filterCutoff" min="20" max="20000" step="1" value="20000">
                        <span class="knob-value">20kHz</span>
                    </div>
                </div>
                <div class="control">
                    <label for="filterResonance">Resonance</label>
                    <div class="circular-control" data-unit="">
                        <input type="range" id="filterResonance" min="0" max="20" step="0.1" value="0">
                        <span class="knob-value">0.0</span>
                    </div>
                </div>
                <div class="control">
                    <label for="filterEnvAmount">Env Amount</label>
                    <div class="circular-control" data-unit="%">
                        <input type="range" id="filterEnvAmount" min="0" max="1" step="0.01" value="0">
                        <span class="knob-value">0%</span>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Envelope</h2>
                <div class="control">
                    <label for="attack">Attack</label>
                    <div class="circular-control" data-unit="s" data-format="time">
                        <input type="range" id="attack" min="0" max="2" step="0.01" value="0.05">
                        <span class="knob-value">50ms</span>
                    </div>
                </div>
                <div class="control">
                    <label for="decay">Decay</label>
                    <div class="circular-control" data-unit="s" data-format="time">
                        <input type="range" id="decay" min="0" max="2" step="0.01" value="0.1">
                        <span class="knob-value">100ms</span>
                    </div>
                </div>
                <div class="control">
                    <label for="sustain">Sustain</label>
                    <div class="circular-control" data-unit="%">
                        <input type="range" id="sustain" min="0" max="1" step="0.01" value="0.5">
                        <span class="knob-value">50%</span>
                    </div>
                </div>
                <div class="control">
                    <label for="release">Release</label>
                    <div class="circular-control" data-unit="s" data-format="time">
                        <input type="range" id="release" min="0" max="5" step="0.01" value="0.5">
                        <span class="knob-value">500ms</span>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>LFO</h2>
                <div class="control">
                    <label for="lfoToggle">LFO On/Off</label>
                    <input type="checkbox" id="lfoToggle">
                </div>
                <div class="control">
                    <label for="lfoRate">Rate</label>
                    <div class="circular-control" data-unit="Hz">
                        <input type="range" id="lfoRate" min="0" max="20" step="0.1" value="0">
                        <span class="knob-value">0Hz</span>
                    </div>
                </div>
                <div class="control">
                    <label for="lfoAmount">Amount</label>
                    <div class="circular-control" data-unit="">
                        <input type="range" id="lfoAmount" min="0" max="1000" step="1" value="50">
                        <span class="knob-value">50</span>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Noise</h2>
                <div class="control">
                    <label for="noiseToggle">Noise On/Off</label>
                    <input type="checkbox" id="noiseToggle">
                </div>
                <div class="control">
                    <label for="noiseAmount">Amount</label>
                    <div class="circular-control" data-unit="%">
                        <input type="range" id="noiseAmount" min="0" max="1" step="0.01" value="0">
                        <span class="knob-value">0%</span>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Arpeggiator</h2>
                <div class="control">
                    <label for="arpToggle">Arp On/Off</label>
                    <input type="checkbox" id="arpToggle">
                </div>
                <div class="control">
                    <label for="arpClock">Clock</label>
                    <select id="arpClock">
                        <option value="1">1/1</option>
                        <option value="2">1/2</option>
                        <option value="4">1/4</option>
                        <option value="8">1/8</option>
                        <option value="16" selected>1/16</option>
                        <option value="32">1/32</option>
                        <option value="64">1/64</option>
                    </select>
                </div>
                <div class="control">
                    <label for="arpPattern">Pattern</label>
                    <select id="arpPattern">
                        <option value="up">Up</option>
                        <option value="down">Down</option>
                        <option value="upDown">Up-Down</option>
                        <option value="random">Random</option>
                    </select>
                </div>
                <div class="control">
                    <label for="arpSpeed">Speed</label>
                    <div class="circular-control" data-unit="x">
                        <input type="range" id="arpSpeed" min="1" max="8" step="1" value="4">
                        <span class="knob-value">4x</span>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <h2>Miscellaneous</h2>
                <div class="control">
                    <label for="whiteKeysOnlyToggle">White Keys Only</label>
                    <input type="checkbox" id="whiteKeysOnlyToggle">
                </div>
            </div>
            <div class="control-group">
                <h2>Tuning</h2>
                <div class="control">
                    <label for="tuningPreset">Select Tuning</label>
                    <select id="tuningPreset">
                        <option value="">Default (12-TET)</option>
                        <option value="13-tone">13-Tone Scale</option>
                        <option value="17-tone">17-Tone Scale ❤️</option>
                        <option value="24-tone">24-Tone Scale</option>
                    </select>
                </div>
                <div class="control">
                    <label for="tuningFile">Or import .tun file</label>
                    <input type="file" id="tuningFile" accept=".tun">
                </div>
                <div class="control">
                    <div class="tuning-buttons">
                        <button id="applyTuning" class="control-button" disabled>Apply Tuning</button>
                        <button id="resetTuning" class="control-button">Reset Tuning</button>
                    </div>
                </div>
            </div>
        </div>
        <p id="footer">we like <a href="https://hypertrance.eu/" target="_blank"
                rel="noopener noreferrer">hypertrance</a> ❤️</p>
    </div>
    <script>
        let loadedTuningContent = null;

        // Synth configuration object
        const SynthConfig = {
            waveforms: ['sine', 'square', 'sawtooth', 'triangle'],
            filterTypes: ['lowpass', 'highpass', 'bandpass'],
            notes: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
            whiteNotes: ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
            blackNotes: ['C#', 'D#', 'F#', 'G#', 'A#'],
            keyboardMap: {
                // Existing mappings
                'z': 'C3', 'x': 'D3', 'c': 'E3', 'v': 'F3', 'b': 'G3', 'n': 'A3', 'm': 'B3',
                'q': 'C4', 'w': 'D4', 'e': 'E4', 'r': 'F4', 't': 'G4', 'y': 'A4', 'u': 'B4',
                'i': 'C5', 'o': 'D5', 'p': 'E5', '[': 'F5', ']': 'G5',
                's': 'C#3', 'd': 'D#3', 'g': 'F#3', 'h': 'G#3', 'j': 'A#3',
                '2': 'C#4', '3': 'D#4', '5': 'F#4', '6': 'G#4', '7': 'A#4',
                '9': 'C#5', '0': 'D#5', '=': 'F#5',
                ',': 'C4', '.': 'D4', '/': 'E4',
                'a': 'A3', 'k': 'B3', 'l': 'C4', ';': 'D4', "'": 'E4',
                'ı': 'C5', 'ğ': 'F5', 'ü': 'G5',
                'ö': 'C4', 'ç': 'D4',

                'numpad0': 'G3', 'numpadinsert': 'G3',
                'numpaddelete': 'A3', 'numpad,': 'A3',
                'numpadenter': 'B3',
                'numpad1': 'C4', 'numpadend': 'C4',
                'numpad2': 'D4', 'numpadarrowdown': 'D4',
                'numpad3': 'E4', 'numpadpagedown': 'E4',
                'numpad4': 'F4', 'numpadarrowleft': 'F4',
                'numpad5': 'G4', 'numpadclear': 'G4',
                'numpad6': 'A4', 'numpadarrowright': 'A4',
                'numpad7': 'B4', 'numpadhome': 'B4',
                'numpad8': 'C5', 'numpadarrowup': 'C5',
                'numpad9': 'D5', 'numpadpageup': 'D5',
                'numpad+': 'E5',
                'numpad': 'F5',
                'numpad/': 'G5',
                'numpad*': 'A5', 'numpad-': 'A4',

                'arrowup': 'F3',
                'arrowright': 'E3',
                'arrowdown': 'D3',
                'arrowleft': 'C3'
            },
            whiteKeysOnlyMap: {
                'z': 'C3', 'x': 'D3', 'c': 'E3', 'v': 'F3', 'b': 'G3', 'n': 'A3', 'm': 'B3', ',': 'C4', 'ö': 'C4', '.': 'D4', 'ç': 'D4', '/': 'E4',
                'a': 'C4', 's': 'D4', 'd': 'E4', 'f': 'F4', 'g': 'G4', 'h': 'A4', 'j': 'B4', 'k': 'C5', 'l': 'D5', ';': 'E5', 'ş': 'E5', "'": 'F5', 'i': 'F5',
                'q': 'C5', 'w': 'D5', 'e': 'E5', 'r': 'F5', 't': 'G5', 'y': 'A5', 'u': 'B5', 'ı': 'C6', 'o': 'D6', 'p': 'E6', '[': 'F6', 'ğ': 'F6', ']': 'G6', 'ü': 'G6',
                '1': 'C6', '2': 'D6', '3': 'E6', '4': 'F6', '5': 'G6', '6': 'A6', '7': 'B6', '8': 'C7', '9': 'D7', '0': 'E7', '-': 'F7', '*': 'F7', '=': 'G7', '-': 'G7',

                'numpad0': 'G3', 'numpadinsert': 'G3',
                'numpaddelete': 'A3', 'numpad,': 'A3',
                'numpadenter': 'B3',
                'numpad1': 'C4', 'numpadend': 'C4',
                'numpad2': 'D4', 'numpadarrowdown': 'D4',
                'numpad3': 'E4', 'numpadpagedown': 'E4',
                'numpad4': 'F4', 'numpadarrowleft': 'F4',
                'numpad5': 'G4', 'numpadclear': 'G4',
                'numpad6': 'A4', 'numpadarrowright': 'A4',
                'numpad7': 'B4', 'numpadhome': 'B4',
                'numpad8': 'C5', 'numpadarrowup': 'C5',
                'numpad9': 'D5', 'numpadpageup': 'D5',
                'numpad+': 'E5',
                'numpad': 'F5',
                'numpad/': 'G5',
                'numpad*': 'A5', 'numpad-': 'A4',

                'arrowup': 'F3',
                'arrowright': 'E3',
                'arrowdown': 'D3',
                'arrowleft': 'C3'
            },
            maxPolyphony: 8,
        };
        // New Tuning System
        const TuningSystem = {
            frequencies: new Array(128).fill(null),
            isCustomTuning: false,
            // Update the parseTunFile method in TuningSystem
            parseTunFile(content, scaleType) {
                console.log('Parsing tuning file...');
                const lines = content.split('\n');
                const frequencies = new Array(128).fill(null);

                // Reference C4 = 261.63 Hz (MIDI note 60)
                const MIDDLE_C = 261.63;
                const OCTAVE_RATIO = 2;

                // Set steps per octave based on scale type
                const STEPS_PER_OCTAVE = {
                    '17-tone': 17,
                    '13-tone': 13,
                    '24-tone': 24
                }[scaleType] || 12; // default to 12 if scale type not found

                const STEP_RATIO = Math.pow(OCTAVE_RATIO, 1 / STEPS_PER_OCTAVE);

                const c4Index = 60;  // MIDI note number for C4

                lines.forEach((line, index) => {
                    line = line.trim();

                    if (line.startsWith('note ')) {
                        const parts = line.split('=');
                        if (parts.length !== 2) return;

                        const noteNumber = parseInt(parts[0].replace('note ', ''));
                        let value = parseFloat(parts[1].trim());

                        if (!isNaN(noteNumber) && !isNaN(value) && noteNumber >= 0 && noteNumber < 128) {
                            // Calculate steps from C4
                            const stepsFromC4 = noteNumber - c4Index;

                            // Calculate the frequency relative to C4
                            const scaledFreq = MIDDLE_C * Math.pow(STEP_RATIO, stepsFromC4);

                            frequencies[noteNumber] = scaledFreq;
                            console.log(`Setting note ${noteNumber} to ${scaledFreq}Hz (scaled from ${value}Hz)`);
                        }
                    }
                });

                // Validate the parsed data
                const validCount = frequencies.filter(f => f !== null).length;
                console.log(`Successfully parsed ${validCount} frequencies`);

                if (validCount === 0) {
                    console.error('No valid frequencies found in file!');
                    return null;
                }

                return frequencies;
            },
            importTuning(frequencies) {
                if (!frequencies || frequencies.every(f => f === null)) {
                    console.error('Invalid frequencies provided to import');
                    return;
                }

                console.log('Importing new tuning...');
                this.frequencies = frequencies;
                this.isCustomTuning = true;

                // Validate the import
                const validCount = this.frequencies.filter(f => f !== null).length;
                console.log(`Imported ${validCount} frequencies`);
                console.log('Custom tuning is now:', this.isCustomTuning);
                console.log('Sample of active frequencies:', this.frequencies.slice(60, 72));
            },
            resetToDefaultTuning() {
                console.log('Resetting to default tuning');
                this.frequencies = new Array(128).fill(null);
                this.isCustomTuning = false;
            },

            noteToFreq: function (note) { // Use function keyword to maintain correct 'this' binding
                if (!note) return 0;

                const matches = note.match(/([A-G]#?)(\d+)/);
                if (!matches) {
                    console.error('Invalid note format:', note);
                    return 0;
                }

                const [_, noteName, octaveStr] = matches;
                const octave = parseInt(octaveStr);
                const noteIndex = SynthConfig.notes.indexOf(noteName);
                const midiNote = noteIndex + (octave + 1) * 12;

                if (this.isCustomTuning && this.frequencies[midiNote] !== null) {
                    const customFreq = this.frequencies[midiNote];
                    return customFreq;
                }

                const defaultFreq = 440 * Math.pow(2, (midiNote - 69) / 12);
                return defaultFreq;
            }
        };
        // Synth state
        const SynthState = {
            activeVoices: {},
            activeNotes: new Set(),
            controls: {},
            fmEnabled: false,
            lfoEnabled: false,
            noiseEnabled: false,
            whiteKeysOnly: false,
            arpeggiator: {
                isOn: false,
                pattern: 'up',
                speed: 4, // Default speed (middle of the range 1-8)
                notes: [],
                currentIndex: 0,
                intervalId: null
            },
            filterEnabled: true,
            filterSettings: {
                type: 'lowpass',
                frequency: 1000,
                Q: 0
            },
            wavetable: {
                frames: [],
                position: 0,
                periodicWave: null
            }
        };

        // Wavetable Editor System
        const WavetableEditor = {
            FRAME_SIZE: 2048,
            frames: [],
            currentFrame: 0,
            currentTool: 'draw',
            isDrawing: false,
            lastDrawPoint: null,
            canvas2D: null,
            ctx2D: null,
            canvas3D: null,
            gl: null,
            rotateX: -30,
            rotateY: 30,
            zoom: 1.5,
            animationId: null,
            isDragging3D: false,
            lastMouseX: 0,
            lastMouseY: 0,

            init() {
                // Initialize with 8 frames of sine waves morphing to saw
                this.frames = [];
                for (let i = 0; i < 8; i++) {
                    const frame = new Float32Array(this.FRAME_SIZE);
                    const morphAmount = i / 7;
                    for (let j = 0; j < this.FRAME_SIZE; j++) {
                        const phase = (j / this.FRAME_SIZE) * Math.PI * 2;
                        // Morph from sine to sawtooth
                        const sine = Math.sin(phase);
                        const saw = 1 - 2 * (j / this.FRAME_SIZE);
                        frame[j] = sine * (1 - morphAmount) + saw * morphAmount;
                    }
                    this.frames.push(frame);
                }

                this.canvas2D = document.getElementById('wavetable2D');
                this.ctx2D = this.canvas2D.getContext('2d');
                this.canvas3D = document.getElementById('wavetable3D');

                this.initWebGL();
                this.setupEventListeners();
                this.updateFrameDisplay();
            },

            initWebGL() {
                this.gl = this.canvas3D.getContext('webgl') || this.canvas3D.getContext('experimental-webgl');
                if (!this.gl) {
                    console.error('WebGL not supported, falling back to 2D');
                    return;
                }

                const gl = this.gl;

                // Vertex shader - handles 3D positioning
                const vsSource = `
                    attribute vec3 aPosition;
                    attribute vec3 aColor;
                    uniform mat4 uModelViewMatrix;
                    uniform mat4 uProjectionMatrix;
                    varying vec3 vColor;
                    void main() {
                        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                        vColor = aColor;
                    }
                `;

                // Fragment shader - handles coloring
                const fsSource = `
                    precision mediump float;
                    varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4(vColor, 1.0);
                    }
                `;

                // Compile shaders
                const vertexShader = this.compileShader(gl, gl.VERTEX_SHADER, vsSource);
                const fragmentShader = this.compileShader(gl, gl.FRAGMENT_SHADER, fsSource);

                // Create program
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);

                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    console.error('Shader program failed:', gl.getProgramInfoLog(this.program));
                    return;
                }

                // Get attribute/uniform locations
                this.attribLocations = {
                    position: gl.getAttribLocation(this.program, 'aPosition'),
                    color: gl.getAttribLocation(this.program, 'aColor')
                };
                this.uniformLocations = {
                    modelViewMatrix: gl.getUniformLocation(this.program, 'uModelViewMatrix'),
                    projectionMatrix: gl.getUniformLocation(this.program, 'uProjectionMatrix')
                };

                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            },

            compileShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            },

            // Matrix math helpers
            createPerspectiveMatrix(fov, aspect, near, far) {
                const f = 1.0 / Math.tan(fov / 2);
                return new Float32Array([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (far + near) / (near - far), -1,
                    0, 0, (2 * far * near) / (near - far), 0
                ]);
            },

            createModelViewMatrix() {
                const rx = this.rotateX * Math.PI / 180;
                const ry = this.rotateY * Math.PI / 180;
                const z = -3 / this.zoom;

                // Rotation matrices
                const cosX = Math.cos(rx), sinX = Math.sin(rx);
                const cosY = Math.cos(ry), sinY = Math.sin(ry);

                return new Float32Array([
                    cosY, sinX * sinY, -cosX * sinY, 0,
                    0, cosX, sinX, 0,
                    sinY, -sinX * cosY, cosX * cosY, 0,
                    0, 0, z, 1
                ]);
            },

            render3D() {
                if (!this.gl) return;

                const gl = this.gl;
                const canvas = this.canvas3D;

                // Set canvas size
                canvas.width = canvas.offsetWidth * window.devicePixelRatio;
                canvas.height = canvas.offsetHeight * window.devicePixelRatio;
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Clear
                gl.clearColor(0.1, 0.1, 0.1, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                gl.useProgram(this.program);

                // Generate mesh data
                const { positions, colors, indices } = this.generateWavetableMesh();

                // Position buffer
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(this.attribLocations.position);
                gl.vertexAttribPointer(this.attribLocations.position, 3, gl.FLOAT, false, 0, 0);

                // Color buffer
                const colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(this.attribLocations.color);
                gl.vertexAttribPointer(this.attribLocations.color, 3, gl.FLOAT, false, 0, 0);

                // Index buffer
                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

                // Set matrices
                const projectionMatrix = this.createPerspectiveMatrix(
                    45 * Math.PI / 180,
                    canvas.width / canvas.height,
                    0.1,
                    100
                );
                const modelViewMatrix = this.createModelViewMatrix();

                gl.uniformMatrix4fv(this.uniformLocations.projectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(this.uniformLocations.modelViewMatrix, false, modelViewMatrix);

                // Draw
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

                // Draw wireframe on top
                gl.depthFunc(gl.LEQUAL);
                this.renderWireframe(gl, positions);

                // Cleanup
                gl.deleteBuffer(positionBuffer);
                gl.deleteBuffer(colorBuffer);
                gl.deleteBuffer(indexBuffer);
            },

            renderWireframe(gl, positions) {
                // Create line mesh for wireframe effect
                const linePositions = [];
                const lineColors = [];
                const samplesPerFrame = 64;
                const numFrames = this.frames.length;

                // Draw horizontal lines (waveforms)
                for (let f = 0; f < numFrames; f++) {
                    const frame = this.frames[f];
                    const z = (f / (numFrames - 1)) * 2 - 1;
                    const isCurrentFrame = f === this.currentFrame;

                    for (let i = 0; i < samplesPerFrame - 1; i++) {
                        const x1 = (i / (samplesPerFrame - 1)) * 2 - 1;
                        const x2 = ((i + 1) / (samplesPerFrame - 1)) * 2 - 1;
                        const sampleIdx1 = Math.floor((i / samplesPerFrame) * this.FRAME_SIZE);
                        const sampleIdx2 = Math.floor(((i + 1) / samplesPerFrame) * this.FRAME_SIZE);
                        const y1 = frame[sampleIdx1] * 0.5;
                        const y2 = frame[sampleIdx2] * 0.5;

                        linePositions.push(x1, y1, z, x2, y2, z);

                        // Cyan for current frame, gradient for others
                        if (isCurrentFrame) {
                            lineColors.push(0, 1, 0.62, 0, 1, 0.62);
                        } else {
                            const brightness = 0.3 + (f / numFrames) * 0.4;
                            lineColors.push(0, brightness, brightness * 0.62, 0, brightness, brightness * 0.62);
                        }
                    }
                }

                const lineBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, lineBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(linePositions), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(this.attribLocations.position);
                gl.vertexAttribPointer(this.attribLocations.position, 3, gl.FLOAT, false, 0, 0);

                const lineColorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, lineColorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lineColors), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(this.attribLocations.color);
                gl.vertexAttribPointer(this.attribLocations.color, 3, gl.FLOAT, false, 0, 0);

                gl.drawArrays(gl.LINES, 0, linePositions.length / 3);

                gl.deleteBuffer(lineBuffer);
                gl.deleteBuffer(lineColorBuffer);
            },

            generateWavetableMesh() {
                const positions = [];
                const colors = [];
                const indices = [];

                const samplesPerFrame = 64;
                const numFrames = this.frames.length;

                // Generate vertices
                for (let f = 0; f < numFrames; f++) {
                    const frame = this.frames[f];
                    const z = (f / (numFrames - 1)) * 2 - 1;

                    for (let i = 0; i < samplesPerFrame; i++) {
                        const x = (i / (samplesPerFrame - 1)) * 2 - 1;
                        const sampleIdx = Math.floor((i / samplesPerFrame) * this.FRAME_SIZE);
                        const y = frame[sampleIdx] * 0.5;

                        positions.push(x, y, z);

                        // Color based on height and frame position
                        const hue = (f / numFrames) * 0.3; // Cyan to green
                        const brightness = 0.15 + Math.abs(y) * 0.3;
                        colors.push(hue * 0.5, brightness + 0.2, brightness * 0.62 + 0.2);
                    }
                }

                // Generate indices for triangles
                for (let f = 0; f < numFrames - 1; f++) {
                    for (let i = 0; i < samplesPerFrame - 1; i++) {
                        const topLeft = f * samplesPerFrame + i;
                        const topRight = topLeft + 1;
                        const bottomLeft = (f + 1) * samplesPerFrame + i;
                        const bottomRight = bottomLeft + 1;

                        indices.push(topLeft, bottomLeft, topRight);
                        indices.push(topRight, bottomLeft, bottomRight);
                    }
                }

                return { positions, colors, indices };
            },

            render2D() {
                const canvas = this.canvas2D;
                const ctx = this.ctx2D;
                const frame = this.frames[this.currentFrame];

                canvas.width = canvas.offsetWidth * window.devicePixelRatio;
                canvas.height = canvas.offsetHeight * window.devicePixelRatio;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;

                // Background
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, width, height);

                // Grid
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                // Vertical lines
                for (let i = 0; i <= 8; i++) {
                    const x = (i / 8) * width;
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                }
                // Horizontal lines
                for (let i = 0; i <= 4; i++) {
                    const y = (i / 4) * height;
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                }
                ctx.stroke();

                // Center line
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();

                // Waveform
                ctx.strokeStyle = '#00ff9d';
                ctx.lineWidth = 2;
                ctx.beginPath();

                const samplesPerPixel = this.FRAME_SIZE / width;
                for (let x = 0; x < width; x++) {
                    const sampleIdx = Math.floor(x * samplesPerPixel);
                    const y = height / 2 - frame[sampleIdx] * (height / 2 - 10);
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Glow effect
                ctx.strokeStyle = 'rgba(0, 255, 157, 0.3)';
                ctx.lineWidth = 6;
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const sampleIdx = Math.floor(x * samplesPerPixel);
                    const y = height / 2 - frame[sampleIdx] * (height / 2 - 10);
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            },

            setupEventListeners() {
                // 2D Canvas drawing
                this.canvas2D.addEventListener('mousedown', (e) => this.startDraw(e));
                this.canvas2D.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas2D.addEventListener('mouseup', () => this.endDraw());
                this.canvas2D.addEventListener('mouseleave', () => this.endDraw());

                // 3D Canvas rotation
                this.canvas3D.addEventListener('mousedown', (e) => {
                    this.isDragging3D = true;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                });
                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging3D) {
                        const deltaX = e.clientX - this.lastMouseX;
                        const deltaY = e.clientY - this.lastMouseY;
                        this.rotateY += deltaX * 0.5;
                        this.rotateX += deltaY * 0.5;
                        this.rotateX = Math.max(-90, Math.min(90, this.rotateX));
                        this.lastMouseX = e.clientX;
                        this.lastMouseY = e.clientY;
                        document.getElementById('wt3dRotateX').value = this.rotateX;
                        this.render3D();
                    }
                });
                document.addEventListener('mouseup', () => {
                    this.isDragging3D = false;
                });

                // 3D Controls
                document.getElementById('wt3dRotateX').addEventListener('input', (e) => {
                    this.rotateX = parseFloat(e.target.value);
                    this.render3D();
                });
                document.getElementById('wt3dZoom').addEventListener('input', (e) => {
                    this.zoom = parseFloat(e.target.value);
                    this.render3D();
                });

                // Frame navigation
                document.getElementById('prevFrame').addEventListener('click', () => {
                    this.currentFrame = Math.max(0, this.currentFrame - 1);
                    this.updateFrameDisplay();
                });
                document.getElementById('nextFrame').addEventListener('click', () => {
                    this.currentFrame = Math.min(this.frames.length - 1, this.currentFrame + 1);
                    this.updateFrameDisplay();
                });
                document.getElementById('addFrame').addEventListener('click', () => this.addFrame());
                document.getElementById('deleteFrame').addEventListener('click', () => this.deleteFrame());

                // Tools
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentTool = btn.id.replace('tool', '').toLowerCase();
                        if (this.currentTool === 'smooth') this.smoothFrame();
                        if (this.currentTool === 'normalize') this.normalizeFrame();
                    });
                });

                // Preset waveforms
                document.getElementById('presetWaveform').addEventListener('change', (e) => {
                    if (e.target.value) {
                        this.loadPresetShape(e.target.value);
                        e.target.value = '';
                    }
                });

                // Wavetable presets
                document.getElementById('wavetablePresets').addEventListener('change', (e) => {
                    if (e.target.value) {
                        this.loadWavetablePreset(e.target.value);
                        e.target.value = '';
                    }
                });

                // Modal controls
                document.getElementById('openWavetableEditor').addEventListener('click', () => this.open());
                document.getElementById('closeWavetableEditor').addEventListener('click', () => this.close());
                document.getElementById('applyWavetable').addEventListener('click', () => this.apply());
            },

            startDraw(e) {
                this.isDrawing = true;
                this.lastDrawPoint = this.getCanvasPoint(e);
                this.drawAt(this.lastDrawPoint);
            },

            draw(e) {
                if (!this.isDrawing) return;
                const point = this.getCanvasPoint(e);

                if (this.currentTool === 'draw') {
                    // Interpolate between last point and current for smooth lines
                    if (this.lastDrawPoint) {
                        this.drawLine(this.lastDrawPoint, point);
                    }
                    this.lastDrawPoint = point;
                } else if (this.currentTool === 'line') {
                    // Preview line
                    this.render2D();
                    const ctx = this.ctx2D;
                    ctx.strokeStyle = 'rgba(0, 255, 157, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const height = this.canvas2D.offsetHeight;
                    const startY = height / 2 - this.lastDrawPoint.value * (height / 2 - 10);
                    const endY = height / 2 - point.value * (height / 2 - 10);
                    ctx.moveTo(this.lastDrawPoint.x * this.canvas2D.offsetWidth, startY);
                    ctx.lineTo(point.x * this.canvas2D.offsetWidth, endY);
                    ctx.stroke();
                }
            },

            endDraw() {
                if (this.isDrawing && this.currentTool === 'line' && this.lastDrawPoint) {
                    const point = this.lastDrawPoint;
                    // Line tool - draw the final line
                }
                this.isDrawing = false;
                this.lastDrawPoint = null;
                this.render2D();
                this.render3D();
            },

            getCanvasPoint(e) {
                const rect = this.canvas2D.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;
                const value = 1 - y * 2; // Map to -1 to 1
                return { x: Math.max(0, Math.min(1, x)), value: Math.max(-1, Math.min(1, value)) };
            },

            drawAt(point) {
                const frame = this.frames[this.currentFrame];
                const sampleIdx = Math.floor(point.x * this.FRAME_SIZE);
                const brushSize = 20;

                for (let i = -brushSize; i <= brushSize; i++) {
                    const idx = sampleIdx + i;
                    if (idx >= 0 && idx < this.FRAME_SIZE) {
                        const distance = Math.abs(i) / brushSize;
                        const influence = 1 - distance * distance;
                        frame[idx] = frame[idx] * (1 - influence) + point.value * influence;
                    }
                }
                this.render2D();
            },

            drawLine(start, end) {
                const frame = this.frames[this.currentFrame];
                const startIdx = Math.floor(start.x * this.FRAME_SIZE);
                const endIdx = Math.floor(end.x * this.FRAME_SIZE);
                const steps = Math.abs(endIdx - startIdx) + 1;

                for (let i = 0; i < steps; i++) {
                    const t = steps === 1 ? 0 : i / (steps - 1);
                    const idx = Math.round(startIdx + (endIdx - startIdx) * t);
                    const value = start.value + (end.value - start.value) * t;

                    if (idx >= 0 && idx < this.FRAME_SIZE) {
                        frame[idx] = value;
                    }
                }
                this.render2D();
            },

            smoothFrame() {
                const frame = this.frames[this.currentFrame];
                const smoothed = new Float32Array(this.FRAME_SIZE);
                const windowSize = 5;

                for (let i = 0; i < this.FRAME_SIZE; i++) {
                    let sum = 0;
                    let count = 0;
                    for (let j = -windowSize; j <= windowSize; j++) {
                        const idx = (i + j + this.FRAME_SIZE) % this.FRAME_SIZE;
                        sum += frame[idx];
                        count++;
                    }
                    smoothed[i] = sum / count;
                }

                this.frames[this.currentFrame] = smoothed;
                this.render2D();
                this.render3D();
            },

            normalizeFrame() {
                const frame = this.frames[this.currentFrame];
                let max = 0;
                for (let i = 0; i < this.FRAME_SIZE; i++) {
                    max = Math.max(max, Math.abs(frame[i]));
                }
                if (max > 0) {
                    for (let i = 0; i < this.FRAME_SIZE; i++) {
                        frame[i] /= max;
                    }
                }
                this.render2D();
                this.render3D();
            },

            addFrame() {
                if (this.frames.length >= 64) return;
                const newFrame = new Float32Array(this.FRAME_SIZE);
                // Copy current frame
                newFrame.set(this.frames[this.currentFrame]);
                this.frames.splice(this.currentFrame + 1, 0, newFrame);
                this.currentFrame++;
                this.updateFrameDisplay();
            },

            deleteFrame() {
                if (this.frames.length <= 1) return;
                this.frames.splice(this.currentFrame, 1);
                this.currentFrame = Math.min(this.currentFrame, this.frames.length - 1);
                this.updateFrameDisplay();
            },

            updateFrameDisplay() {
                document.getElementById('currentFrameNum').textContent = this.currentFrame + 1;
                document.getElementById('totalFrames').textContent = this.frames.length;
                this.render2D();
                this.render3D();
            },

            loadPresetShape(type) {
                const frame = this.frames[this.currentFrame];
                for (let i = 0; i < this.FRAME_SIZE; i++) {
                    const phase = (i / this.FRAME_SIZE) * Math.PI * 2;
                    const t = i / this.FRAME_SIZE;

                    switch (type) {
                        case 'sine':
                            frame[i] = Math.sin(phase);
                            break;
                        case 'triangle':
                            frame[i] = 2 * Math.abs(2 * t - 1) - 1;
                            break;
                        case 'sawtooth':
                            frame[i] = 2 * t - 1;
                            break;
                        case 'square':
                            frame[i] = t < 0.5 ? 1 : -1;
                            break;
                        case 'pulse25':
                            frame[i] = t < 0.25 ? 1 : -1;
                            break;
                        case 'pulse10':
                            frame[i] = t < 0.1 ? 1 : -1;
                            break;
                        case 'random':
                            frame[i] = Math.random() * 2 - 1;
                            break;
                        case 'clear':
                            frame[i] = 0;
                            break;
                    }
                }
                this.render2D();
                this.render3D();
            },

            loadWavetablePreset(type) {
                this.frames = [];
                const numFrames = 8;

                for (let f = 0; f < numFrames; f++) {
                    const frame = new Float32Array(this.FRAME_SIZE);
                    const morph = f / (numFrames - 1);

                    for (let i = 0; i < this.FRAME_SIZE; i++) {
                        const phase = (i / this.FRAME_SIZE) * Math.PI * 2;
                        const t = i / this.FRAME_SIZE;

                        switch (type) {
                            case 'basic':
                                // Sine -> Triangle -> Saw -> Square
                                const sine = Math.sin(phase);
                                const tri = 2 * Math.abs(2 * t - 1) - 1;
                                const saw = 2 * t - 1;
                                const square = t < 0.5 ? 1 : -1;
                                if (morph < 0.33) {
                                    const m = morph / 0.33;
                                    frame[i] = sine * (1 - m) + tri * m;
                                } else if (morph < 0.66) {
                                    const m = (morph - 0.33) / 0.33;
                                    frame[i] = tri * (1 - m) + saw * m;
                                } else {
                                    const m = (morph - 0.66) / 0.34;
                                    frame[i] = saw * (1 - m) + square * m;
                                }
                                break;

                            case 'pwm':
                                // Pulse width modulation
                                const pw = 0.1 + morph * 0.4;
                                frame[i] = t < pw ? 1 : -1;
                                break;

                            case 'formant':
                                // Formant-like harmonics
                                const fundamental = Math.sin(phase);
                                const h2 = Math.sin(phase * 2) * (0.5 - morph * 0.4);
                                const h3 = Math.sin(phase * 3) * (0.3 + morph * 0.4);
                                const h4 = Math.sin(phase * 4) * morph * 0.3;
                                const h5 = Math.sin(phase * 5) * morph * 0.2;
                                frame[i] = (fundamental + h2 + h3 + h4 + h5) / 2;
                                break;

                            case 'digital':
                                // Bit-crushed / digital
                                const bits = 2 + Math.floor(morph * 6);
                                const levels = Math.pow(2, bits);
                                const rawSaw = 2 * t - 1;
                                frame[i] = Math.round(rawSaw * levels) / levels;
                                break;

                            case 'analog':
                                // Soft saturation / analog warmth
                                const rawVal = Math.sin(phase) + Math.sin(phase * 2) * 0.5 * morph;
                                const drive = 1 + morph * 3;
                                frame[i] = Math.tanh(rawVal * drive) / Math.tanh(drive);
                                break;

                            case 'vocal':
                                // Vowel-like formants
                                const f1 = Math.sin(phase);
                                const f2 = Math.sin(phase * (2 + morph * 2)) * 0.5;
                                const f3 = Math.sin(phase * (4 + morph * 4)) * 0.25;
                                frame[i] = (f1 + f2 + f3) / 1.75;
                                break;
                        }
                    }
                    this.frames.push(frame);
                }

                this.currentFrame = 0;
                this.updateFrameDisplay();
            },

            open() {
                document.getElementById('wavetableModal').style.display = 'flex';
                setTimeout(() => {
                    this.render2D();
                    this.render3D();
                }, 50);
            },

            close() {
                document.getElementById('wavetableModal').style.display = 'none';
            },

            apply() {
                // Copy frames to synth state
                SynthState.wavetable.frames = this.frames.map(f => new Float32Array(f));

                // Create PeriodicWave for current position
                this.updatePeriodicWave();

                this.close();
            },

            updatePeriodicWave() {
                if (!Synth.audioContext || this.frames.length === 0) return;

                const position = SynthState.wavetable.position;
                const frameIdx = position * (this.frames.length - 1);
                const lowerIdx = Math.floor(frameIdx);
                const upperIdx = Math.min(lowerIdx + 1, this.frames.length - 1);
                const blend = frameIdx - lowerIdx;

                // Interpolate between frames
                const interpolated = new Float32Array(this.FRAME_SIZE);
                for (let i = 0; i < this.FRAME_SIZE; i++) {
                    interpolated[i] = this.frames[lowerIdx][i] * (1 - blend) + this.frames[upperIdx][i] * blend;
                }

                // FFT to get harmonics for PeriodicWave
                const real = new Float32Array(this.FRAME_SIZE / 2);
                const imag = new Float32Array(this.FRAME_SIZE / 2);

                // Simple DFT for harmonics (first 256 harmonics)
                const numHarmonics = Math.min(256, this.FRAME_SIZE / 2);
                for (let k = 0; k < numHarmonics; k++) {
                    let realSum = 0, imagSum = 0;
                    for (let n = 0; n < this.FRAME_SIZE; n++) {
                        const angle = -2 * Math.PI * k * n / this.FRAME_SIZE;
                        realSum += interpolated[n] * Math.cos(angle);
                        imagSum += interpolated[n] * Math.sin(angle);
                    }
                    real[k] = realSum / this.FRAME_SIZE;
                    imag[k] = imagSum / this.FRAME_SIZE;
                }

                real[0] = 0; // Remove DC offset

                try {
                    SynthState.wavetable.periodicWave = Synth.audioContext.createPeriodicWave(real, imag, { disableNormalization: false });
                } catch (e) {
                    console.error('Failed to create PeriodicWave:', e);
                }
            },

            getInterpolatedFrame(position) {
                if (this.frames.length === 0) return null;

                const frameIdx = position * (this.frames.length - 1);
                const lowerIdx = Math.floor(frameIdx);
                const upperIdx = Math.min(lowerIdx + 1, this.frames.length - 1);
                const blend = frameIdx - lowerIdx;

                const interpolated = new Float32Array(this.FRAME_SIZE);
                for (let i = 0; i < this.FRAME_SIZE; i++) {
                    interpolated[i] = this.frames[lowerIdx][i] * (1 - blend) + this.frames[upperIdx][i] * blend;
                }
                return interpolated;
            }
        };

        // Utility functions
        const Util = {
            noteToFreq(note) {
                // Call noteToFreq directly on TuningSystem instead of using bind
                return TuningSystem.noteToFreq(note);
            },
            createNoiseBuffer() {
                if (!Synth.audioContext) return null;
                const bufferSize = Synth.audioContext.sampleRate;
                const buffer = Synth.audioContext.createBuffer(1, bufferSize, Synth.audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                return buffer;
            },
            formatValue(value, unit, format) {
                const num = parseFloat(value);
                if (format === 'freq') {
                    // Convert linear slider value to logarithmic frequency for display
                    const minFreq = 20, maxFreq = 20000;
                    const normalized = (num - minFreq) / (maxFreq - minFreq);
                    const freq = minFreq * Math.pow(maxFreq / minFreq, normalized);
                    if (freq >= 1000) return (freq / 1000).toFixed(1) + 'kHz';
                    return Math.round(freq) + 'Hz';
                }
                if (format === 'time') {
                    if (num < 1) return Math.round(num * 1000) + 'ms';
                    return num.toFixed(2) + 's';
                }
                if (unit === '%') {
                    return Math.round(num * 100) + '%';
                }
                if (unit === 'x') {
                    return Math.round(num) + 'x';
                }
                if (unit === 'ct') {
                    return Math.round(num) + 'ct';
                }
                if (unit === 'Hz') {
                    return num.toFixed(1) + 'Hz';
                }
                // Default: show number with appropriate precision
                if (Number.isInteger(num)) return num.toString() + unit;
                return num.toFixed(1) + unit;
            }
        };

        // Preset Manager
        const PresetManager = {
            STORAGE_KEY: 'browsynth_presets',

            getPresets() {
                try {
                    const stored = localStorage.getItem(this.STORAGE_KEY);
                    return stored ? JSON.parse(stored) : {};
                } catch (e) {
                    console.error('Error loading presets:', e);
                    return {};
                }
            },

            savePreset(name, settings) {
                const presets = this.getPresets();
                presets[name] = settings;
                try {
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(presets));
                    return true;
                } catch (e) {
                    console.error('Error saving preset:', e);
                    return false;
                }
            },

            deletePreset(name) {
                const presets = this.getPresets();
                delete presets[name];
                try {
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(presets));
                    return true;
                } catch (e) {
                    console.error('Error deleting preset:', e);
                    return false;
                }
            },

            loadPreset(name) {
                const presets = this.getPresets();
                return presets[name] || null;
            },

            updatePresetSelect() {
                const select = document.getElementById('presetSelect');
                if (!select) return;

                // Clear existing options except the first one
                while (select.options.length > 1) {
                    select.remove(1);
                }

                // Add factory presets
                const factoryPresets = this.getFactoryPresets();
                if (Object.keys(factoryPresets).length > 0) {
                    const factoryGroup = document.createElement('optgroup');
                    factoryGroup.label = 'Factory';
                    Object.keys(factoryPresets).forEach(name => {
                        const option = document.createElement('option');
                        option.value = 'factory:' + name;
                        option.textContent = name;
                        factoryGroup.appendChild(option);
                    });
                    select.appendChild(factoryGroup);
                }

                // Add user presets
                const userPresets = this.getPresets();
                if (Object.keys(userPresets).length > 0) {
                    const userGroup = document.createElement('optgroup');
                    userGroup.label = 'User';
                    Object.keys(userPresets).sort().forEach(name => {
                        const option = document.createElement('option');
                        option.value = 'user:' + name;
                        option.textContent = name;
                        userGroup.appendChild(option);
                    });
                    select.appendChild(userGroup);
                }
            },

            getFactoryPresets() {
                return {
                    'Init': {
                        synthMode: 'waveform', waveform: 'sine', unison: '1', detune: '0',
                        fmToggle: false, fmAmount: '0', filterToggle: true, filterType: 'lowpass',
                        filterCutoff: '20000', filterResonance: '0', filterEnvAmount: '0',
                        attack: '0.05', decay: '0.1', sustain: '0.5', release: '0.5',
                        lfoToggle: false, lfoRate: '0', lfoAmount: '50',
                        noiseToggle: false, noiseAmount: '0',
                        masterVolume: '0.7', masterReverb: '0', masterDelay: '0',
                        masterLowEQ: '0', masterMidEQ: '0', masterHighEQ: '0'
                    },
                    'Warm Pad': {
                        synthMode: 'waveform', waveform: 'sawtooth', unison: '4', detune: '25',
                        fmToggle: false, fmAmount: '0', filterToggle: true, filterType: 'lowpass',
                        filterCutoff: '2000', filterResonance: '2', filterEnvAmount: '0.3',
                        attack: '0.8', decay: '0.5', sustain: '0.7', release: '1.5',
                        lfoToggle: true, lfoRate: '0.5', lfoAmount: '200',
                        noiseToggle: false, noiseAmount: '0',
                        masterVolume: '0.6', masterReverb: '0.4', masterDelay: '0.2',
                        masterLowEQ: '2', masterMidEQ: '0', masterHighEQ: '-2'
                    },
                    'Bright Lead': {
                        synthMode: 'waveform', waveform: 'square', unison: '2', detune: '10',
                        fmToggle: false, fmAmount: '0', filterToggle: true, filterType: 'lowpass',
                        filterCutoff: '8000', filterResonance: '5', filterEnvAmount: '0.5',
                        attack: '0.01', decay: '0.2', sustain: '0.6', release: '0.3',
                        lfoToggle: false, lfoRate: '0', lfoAmount: '0',
                        noiseToggle: false, noiseAmount: '0',
                        masterVolume: '0.5', masterReverb: '0.1', masterDelay: '0.15',
                        masterLowEQ: '0', masterMidEQ: '3', masterHighEQ: '2'
                    },
                    'Deep Bass': {
                        synthMode: 'waveform', waveform: 'sawtooth', unison: '1', detune: '0',
                        fmToggle: false, fmAmount: '0', filterToggle: true, filterType: 'lowpass',
                        filterCutoff: '500', filterResonance: '8', filterEnvAmount: '0.6',
                        attack: '0.01', decay: '0.3', sustain: '0.4', release: '0.2',
                        lfoToggle: false, lfoRate: '0', lfoAmount: '0',
                        noiseToggle: false, noiseAmount: '0',
                        masterVolume: '0.7', masterReverb: '0', masterDelay: '0',
                        masterLowEQ: '6', masterMidEQ: '-2', masterHighEQ: '-4'
                    },
                    'Pluck': {
                        synthMode: 'waveform', waveform: 'triangle', unison: '2', detune: '5',
                        fmToggle: false, fmAmount: '0', filterToggle: true, filterType: 'lowpass',
                        filterCutoff: '5000', filterResonance: '3', filterEnvAmount: '0.8',
                        attack: '0.001', decay: '0.4', sustain: '0', release: '0.3',
                        lfoToggle: false, lfoRate: '0', lfoAmount: '0',
                        noiseToggle: false, noiseAmount: '0',
                        masterVolume: '0.6', masterReverb: '0.25', masterDelay: '0.3',
                        masterLowEQ: '0', masterMidEQ: '0', masterHighEQ: '0'
                    },
                    'FM Bell': {
                        synthMode: 'waveform', waveform: 'sine', unison: '1', detune: '0',
                        fmToggle: true, fmAmount: '400', filterToggle: true, filterType: 'lowpass',
                        filterCutoff: '10000', filterResonance: '0', filterEnvAmount: '0',
                        attack: '0.001', decay: '1.5', sustain: '0', release: '2',
                        lfoToggle: false, lfoRate: '0', lfoAmount: '0',
                        noiseToggle: false, noiseAmount: '0',
                        masterVolume: '0.5', masterReverb: '0.5', masterDelay: '0.2',
                        masterLowEQ: '0', masterMidEQ: '0', masterHighEQ: '4'
                    },
                    'Noise Sweep': {
                        synthMode: 'waveform', waveform: 'sawtooth', unison: '3', detune: '30',
                        fmToggle: false, fmAmount: '0', filterToggle: true, filterType: 'lowpass',
                        filterCutoff: '1000', filterResonance: '10', filterEnvAmount: '0.7',
                        attack: '0.5', decay: '1', sustain: '0.5', release: '1',
                        lfoToggle: true, lfoRate: '2', lfoAmount: '500',
                        noiseToggle: true, noiseAmount: '0.15',
                        masterVolume: '0.5', masterReverb: '0.6', masterDelay: '0.4',
                        masterLowEQ: '0', masterMidEQ: '0', masterHighEQ: '0'
                    }
                };
            },

            getCurrentSettings() {
                const settings = {};
                const controlIds = [
                    'synthMode', 'waveform', 'unison', 'detune', 'fmAmount',
                    'filterType', 'filterCutoff', 'filterResonance', 'filterEnvAmount',
                    'attack', 'decay', 'sustain', 'release',
                    'lfoRate', 'lfoAmount', 'noiseAmount',
                    'masterVolume', 'masterReverb', 'masterDelay',
                    'masterLowEQ', 'masterMidEQ', 'masterHighEQ'
                ];
                const checkboxIds = ['fmToggle', 'filterToggle', 'lfoToggle', 'noiseToggle'];

                controlIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) settings[id] = el.value;
                });

                checkboxIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) settings[id] = el.checked;
                });

                return settings;
            },

            applySettings(settings) {
                if (!settings) return;

                Object.entries(settings).forEach(([key, value]) => {
                    const el = document.getElementById(key);
                    if (!el) return;

                    if (el.type === 'checkbox') {
                        el.checked = value;
                        el.dispatchEvent(new Event('change'));
                    } else {
                        el.value = value;
                        el.dispatchEvent(new Event('input'));
                    }
                });

                // Update all knob displays
                if (typeof UI !== 'undefined' && UI.updateCircularControls) {
                    UI.updateCircularControls();
                }
            }
        };

        // MIDI Handler
        const MIDIHandler = {
            midiAccess: null,
            inputs: [],
            enabled: false,

            async init() {
                if (this.enabled) return true; // Already initialized

                if (!navigator.requestMIDIAccess) {
                    console.log('Web MIDI API not supported');
                    this.updateButton('unsupported');
                    return false;
                }

                try {
                    this.midiAccess = await navigator.requestMIDIAccess();
                    this.midiAccess.onstatechange = (e) => this.onStateChange(e);
                    this.connectInputs();
                    this.enabled = true;
                    return true;
                } catch (err) {
                    console.error('MIDI access denied:', err);
                    this.updateButton('denied');
                    return false;
                }
            },

            connectInputs() {
                this.inputs = [];
                for (const input of this.midiAccess.inputs.values()) {
                    input.onmidimessage = (e) => this.onMessage(e);
                    this.inputs.push(input);
                    console.log('MIDI input connected:', input.name);
                }
                this.updateButton(this.inputs.length > 0 ? 'connected' : 'disconnected');
            },

            onStateChange(e) {
                console.log('MIDI state change:', e.port.name, e.port.state);
                this.connectInputs();
            },

            onMessage(e) {
                const [status, note, velocity] = e.data;
                const command = status >> 4;

                // Note On
                if (command === 9 && velocity > 0) {
                    const noteName = this.midiNoteToName(note);
                    if (noteName) Voice.play(noteName);
                }
                // Note Off (or Note On with velocity 0)
                else if (command === 8 || (command === 9 && velocity === 0)) {
                    const noteName = this.midiNoteToName(note);
                    if (noteName) Voice.release(noteName);
                }
                // Pitch Bend
                else if (command === 14) {
                    const bend = ((velocity << 7) | note) / 8192 - 1; // -1 to 1
                    if (SynthState.controls.pitchBendWheel) {
                        SynthState.controls.pitchBendWheel.value = bend;
                        Synth.updatePitchBend(bend);
                    }
                }
                // Control Change
                else if (command === 11) {
                    this.handleCC(note, velocity);
                }
            },

            handleCC(cc, value) {
                const normalized = value / 127;

                // Common CC mappings
                const minFreq = 20, maxFreq = 20000;
                switch (cc) {
                    case 1: // Mod wheel -> Filter cutoff
                        if (SynthState.controls.filterCutoff) {
                            // Map normalized MIDI to slider range (slider is linear, conversion happens in updateParams)
                            const sliderValue = minFreq + normalized * (maxFreq - minFreq);
                            SynthState.controls.filterCutoff.value = sliderValue;
                            Synth.updateParams('filterCutoff');
                        }
                        break;
                    case 7: // Volume
                        if (SynthState.controls.masterVolume) {
                            SynthState.controls.masterVolume.value = normalized;
                            Synth.updateParams('masterVolume');
                        }
                        break;
                    case 74: // Filter cutoff (common mapping)
                        if (SynthState.controls.filterCutoff) {
                            const sliderValue = minFreq + normalized * (maxFreq - minFreq);
                            SynthState.controls.filterCutoff.value = sliderValue;
                            Synth.updateParams('filterCutoff');
                        }
                        break;
                    case 71: // Resonance
                        if (SynthState.controls.filterResonance) {
                            SynthState.controls.filterResonance.value = normalized * 20;
                            Synth.updateParams('filterResonance');
                        }
                        break;
                    case 91: // Reverb
                        if (SynthState.controls.masterReverb) {
                            SynthState.controls.masterReverb.value = normalized;
                            Synth.updateParams('masterReverb');
                        }
                        break;
                }

                // Update UI
                UI.updateCircularControls();
            },

            midiNoteToName(midiNote) {
                const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const octave = Math.floor(midiNote / 12) - 1;
                const note = notes[midiNote % 12];
                return note + octave;
            },

            updateButton(status) {
                const btn = document.getElementById('midiEnableButton');
                if (!btn) return;

                // Remove all status classes
                btn.classList.remove('midi-connected', 'midi-disconnected', 'midi-denied', 'midi-unsupported');

                switch (status) {
                    case 'connected':
                        btn.classList.add('midi-connected');
                        btn.title = 'MIDI Connected: ' + this.inputs.map(i => i.name).join(', ');
                        break;
                    case 'disconnected':
                        btn.classList.add('midi-disconnected');
                        btn.title = 'MIDI enabled - No devices connected';
                        break;
                    case 'denied':
                        btn.classList.add('midi-denied');
                        btn.title = 'MIDI access denied - Click to retry';
                        break;
                    case 'unsupported':
                        btn.classList.add('midi-unsupported');
                        btn.title = 'Web MIDI not supported in this browser';
                        btn.disabled = true;
                        break;
                    default:
                        btn.title = 'Click to enable MIDI input';
                }
            }
        };

        // Synth voice creation and management
        const Voice = {
            create(note) {
                if (!Synth.audioContext) return null;

                // Check synth mode and create appropriate voice
                const synthMode = SynthState.controls.synthMode.value;
                if (synthMode === 'piano') {
                    return StringVoice.create(note);
                }
                const frequency = TuningSystem.noteToFreq(note); // Call directly on TuningSystem
                const now = Synth.audioContext.currentTime;

                const oscillators = [];
                const unisonCount = parseInt(SynthState.controls.unison.value) || 1;
                const detune = parseFloat(SynthState.controls.detune.value) || 0;
                const isWavetable = synthMode === 'wavetable' && SynthState.wavetable.periodicWave;

                for (let i = 0; i < unisonCount; i++) {
                    const osc = Synth.audioContext.createOscillator();
                    if (isWavetable) {
                        osc.setPeriodicWave(SynthState.wavetable.periodicWave);
                    } else {
                        osc.type = SynthState.controls.waveform.value;
                    }
                    osc.frequency.setValueAtTime(frequency, now);
                    const detuneAmount = unisonCount > 1 ? (i / (unisonCount - 1) - 0.5) * detune : 0;
                    osc.detune.setValueAtTime(detuneAmount, now);
                    oscillators.push(osc);
                }

                const gainNode = Synth.audioContext.createGain();
                gainNode.gain.setValueAtTime(0, now);

                const filter = Synth.audioContext.createBiquadFilter();
                filter.type = SynthState.filterSettings.type;
                filter.frequency.setValueAtTime(SynthState.filterSettings.frequency, now);
                filter.Q.setValueAtTime(SynthState.filterSettings.Q, now);

                // Connect nodes based on filter state
                if (SynthState.filterEnabled) {
                    oscillators.forEach(osc => osc.connect(filter));
                    filter.connect(gainNode);
                } else {
                    oscillators.forEach(osc => osc.connect(gainNode));
                }

                const fmOsc = Synth.audioContext.createOscillator();
                fmOsc.frequency.setValueAtTime(frequency * 2, now);
                const fmGain = Synth.audioContext.createGain();
                fmGain.gain.setValueAtTime(0, now);

                const noiseOsc = Synth.audioContext.createBufferSource();
                noiseOsc.buffer = Util.createNoiseBuffer();
                noiseOsc.loop = true;
                const noiseGain = Synth.audioContext.createGain();
                noiseGain.gain.setValueAtTime(0, now);

                const lfo = Synth.audioContext.createOscillator();
                const lfoGain = Synth.audioContext.createGain();
                lfo.frequency.setValueAtTime(parseFloat(SynthState.controls.lfoRate.value), now);
                lfoGain.gain.setValueAtTime(parseFloat(SynthState.controls.lfoAmount.value), now);

                // Connect LFO
                if (SynthState.lfoEnabled) {
                    lfo.connect(lfoGain);
                    lfoGain.connect(filter.frequency);
                }

                const pitchBend = {
                    bend: 0,
                    range: parseInt(SynthState.controls.pitchBendRange?.value) || 2
                };

                const updatePitchBend = (bend) => {
                    const now = Synth.audioContext.currentTime;
                    const bendRange = pitchBend.range * 100; // Convert semitones to cents
                    oscillators.forEach((osc, i) => {
                        const detuneAmount = unisonCount > 1 ? (i / (unisonCount - 1) - 0.5) * detune : 0;
                        const totalDetune = detuneAmount + bend * bendRange;

                        // Ensure the value is finite and within a reasonable range
                        const clampedDetune = Math.max(-4800, Math.min(4800, isFinite(totalDetune) ? totalDetune : 0));

                        osc.detune.setTargetAtTime(clampedDetune, now, 0.01);
                    });
                };

                gainNode.connect(Synth.compressor);

                // Start oscillators
                oscillators.forEach(osc => osc.start(now));
                fmOsc.start(now);
                noiseOsc.start(now);
                lfo.start(now);

                const updateVoice = () => {
                    const now = Synth.audioContext.currentTime;

                    // Update filter
                    if (SynthState.filterEnabled) {
                        filter.type = SynthState.filterSettings.type;
                        filter.frequency.cancelScheduledValues(now);
                        filter.frequency.setValueAtTime(SynthState.filterSettings.frequency, now);
                        filter.Q.cancelScheduledValues(now);
                        filter.Q.setValueAtTime(SynthState.filterSettings.Q, now);

                        oscillators.forEach(osc => {
                            osc.disconnect();
                            osc.connect(filter);
                        });
                        filter.disconnect();
                        filter.connect(gainNode);
                    } else {
                        oscillators.forEach(osc => {
                            osc.disconnect();
                            osc.connect(gainNode);
                        });
                    }

                    // Update oscillators, unison, and detune
                    const newUnisonCount = parseInt(SynthState.controls.unison.value) || 1;
                    const newDetune = parseFloat(SynthState.controls.detune.value) || 0;

                    // Adjust the number of oscillators if unison has changed
                    while (oscillators.length < newUnisonCount) {
                        const newOsc = Synth.audioContext.createOscillator();
                        newOsc.type = SynthState.controls.waveform.value;
                        newOsc.frequency.setValueAtTime(frequency, now);
                        newOsc.start(now);
                        oscillators.push(newOsc);
                    }
                    while (oscillators.length > newUnisonCount) {
                        const oscToRemove = oscillators.pop();
                        oscToRemove.stop(now);
                        oscToRemove.disconnect();
                    }

                    // Update each oscillator
                    oscillators.forEach((osc, i) => {
                        osc.type = SynthState.controls.waveform.value;
                        const detuneAmount = newUnisonCount > 1 ? (i / (newUnisonCount - 1) - 0.5) * newDetune : 0;
                        osc.detune.setValueAtTime(detuneAmount, now);

                        // Reconnect oscillator if filter state has changed
                        osc.disconnect();
                        if (SynthState.filterEnabled) {
                            osc.connect(filter);
                        } else {
                            osc.connect(gainNode);
                        }
                    });

                    // Update FM
                    if (SynthState.fmEnabled) {
                        fmGain.gain.setValueAtTime(parseFloat(SynthState.controls.fmAmount.value), now);
                    } else {
                        fmGain.gain.setValueAtTime(0, now);
                    }

                    // Update Noise
                    if (SynthState.noiseEnabled) {
                        noiseGain.gain.setValueAtTime(parseFloat(SynthState.controls.noiseAmount.value), now);
                        noiseOsc.connect(noiseGain);
                        noiseGain.connect(SynthState.filterEnabled ? filter : gainNode);
                    } else {
                        noiseGain.gain.setValueAtTime(0, now);
                        noiseOsc.disconnect();
                        noiseGain.disconnect();
                    }

                    // Update LFO
                    if (SynthState.lfoEnabled) {
                        lfo.frequency.setValueAtTime(parseFloat(SynthState.controls.lfoRate.value), now);
                        lfoGain.gain.setValueAtTime(parseFloat(SynthState.controls.lfoAmount.value), now);
                        lfo.connect(lfoGain);
                        lfoGain.connect(filter.frequency);
                    } else {
                        lfo.disconnect();
                        lfoGain.disconnect();
                    }
                };

                return {
                    oscillators, gainNode, filter, fmOsc, fmGain, noiseOsc, noiseGain, lfo, lfoGain, updateVoice, updatePitchBend, pitchBend, frequency
                };
            },

            play(note, isArpeggiator = false) {
                if (!Synth.audioContext) return;
                if (SynthState.arpeggiator.isOn && !isArpeggiator) {
                    Arpeggiator.addNote(note);
                    return;
                }
                if (SynthState.activeVoices[note]) return;

                const voice = this.create(note);
                if (!voice) return;

                // Special handling for piano voices
                if (voice.attackOsc) {
                    const now = Synth.audioContext.currentTime;
                    const attackTime = 0.01;  // Very quick attack
                    const decayTime = 0.1;
                    const sustainLevel = parseFloat(SynthState.controls.sustain.value) * 0.7;

                    // Main envelope
                    voice.mainGain.gain.setValueAtTime(0, now);
                    voice.mainGain.gain.linearRampToValueAtTime(1, now + attackTime);
                    voice.mainGain.gain.exponentialRampToValueAtTime(sustainLevel + 0.001, now + attackTime + decayTime);

                    // Attack noise envelope
                    voice.attackGain.gain.setValueAtTime(0.3, now);
                    voice.attackGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);

                    SynthState.activeVoices[note] = voice;
                    SynthState.activeNotes.add(note);
                    Synth.recordNoteEvent(note, true);

                    const keyElement = document.querySelector(`.key[data-note="${note}"]`);
                    if (keyElement) keyElement.classList.add('active');
                    return;
                }

                // Special handling for piano voices
                if (voice.strike) {
                    const now = Synth.audioContext.currentTime;
                    const attackTime = Math.min(0.02, parseFloat(SynthState.controls.attack.value));
                    const decayTime = parseFloat(SynthState.controls.decay.value);
                    const sustain = parseFloat(SynthState.controls.sustain.value) * 0.5;

                    voice.gainNode.gain.cancelScheduledValues(now);
                    voice.gainNode.gain.setValueAtTime(0, now);
                    voice.gainNode.gain.linearRampToValueAtTime(1, now + attackTime);
                    voice.gainNode.gain.exponentialRampToValueAtTime(sustain + 0.001, now + attackTime + decayTime);

                    voice.strikeGain.gain.setValueAtTime(1, now);
                    voice.strikeGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

                    SynthState.activeVoices[note] = voice;
                    SynthState.activeNotes.add(note);
                    Synth.recordNoteEvent(note, true);

                    const keyElement = document.querySelector(`.key[data-note="${note}"]`);
                    if (keyElement) keyElement.classList.add('active');
                    return;
                }

                if (Object.keys(SynthState.activeVoices).length >= SynthConfig.maxPolyphony) {
                    const oldestNote = Object.keys(SynthState.activeVoices)[0];
                    this.release(oldestNote);
                }

                if (voice && voice.updatePitchBend) {
                    const currentPitchBend = parseFloat(SynthState.controls.pitchBendWheel?.value) || 0;
                    voice.updatePitchBend(currentPitchBend);
                }
                SynthState.activeVoices[note] = voice;
                SynthState.activeNotes.add(note);
                Synth.recordNoteEvent(note, true);

                const now = Synth.audioContext.currentTime;
                const attackTime = parseFloat(SynthState.controls.attack.value);
                const decayTime = parseFloat(SynthState.controls.decay.value);
                const sustainLevel = parseFloat(SynthState.controls.sustain.value);

                // Adjust the peak level based on the number of active voices
                const peakLevel = 0.5 / Math.max(1, Math.sqrt(Object.keys(SynthState.activeVoices).length));
                const sustainedLevel = sustainLevel * peakLevel;

                voice.gainNode.gain.linearRampToValueAtTime(peakLevel, now + attackTime);
                voice.gainNode.gain.linearRampToValueAtTime(sustainedLevel, now + attackTime + decayTime);

                // Filter envelope
                const filterEnvAmount = parseFloat(SynthState.controls.filterEnvAmount.value);
                const filterStartFreq = SynthState.filterSettings.frequency;
                const filterPeakFreq = Math.min(filterStartFreq * (1 + filterEnvAmount * 10), Synth.audioContext.sampleRate / 2);

                // Apply noise envelope
                if (SynthState.noiseEnabled) {
                    const noiseAmount = parseFloat(SynthState.controls.noiseAmount.value);
                    voice.noiseGain.gain.cancelScheduledValues(now);
                    voice.noiseGain.gain.setValueAtTime(0, now);
                    voice.noiseGain.gain.linearRampToValueAtTime(noiseAmount, now + attackTime);
                    voice.noiseGain.gain.linearRampToValueAtTime(noiseAmount * sustainLevel, now + attackTime + decayTime);
                }

                // Apply LFO envelope
                if (SynthState.lfoEnabled) {
                    const lfoAmount = parseFloat(SynthState.controls.lfoAmount.value);
                    voice.lfoGain.gain.cancelScheduledValues(now);
                    voice.lfoGain.gain.setValueAtTime(0, now);
                    voice.lfoGain.gain.linearRampToValueAtTime(lfoAmount, now + attackTime);
                }

                if (SynthState.filterEnabled) {
                    voice.filter.frequency.cancelScheduledValues(now);
                    voice.filter.frequency.setValueAtTime(filterStartFreq, now);
                    voice.filter.frequency.linearRampToValueAtTime(filterPeakFreq, now + attackTime);
                    voice.filter.frequency.linearRampToValueAtTime(filterStartFreq, now + attackTime + decayTime);
                }

                const keyElement = document.querySelector(`.key[data-note="${note}"]`);
                if (keyElement) keyElement.classList.add('active');
            },

            release(note, isArpeggiator = false) {
                if (SynthState.arpeggiator.isOn && !isArpeggiator) {
                    Arpeggiator.removeNote(note);
                    return;
                }

                const voice = SynthState.activeVoices[note];
                Synth.recordNoteEvent(note, false);
                if (!voice) return;

                const releaseTime = parseFloat(SynthState.controls.release.value);

                // If voice has custom release method, use it
                if (voice.release) {
                    voice.release(releaseTime);
                } else {
                    const now = Synth.audioContext.currentTime;
                    voice.gainNode.gain.cancelScheduledValues(now);
                    voice.gainNode.gain.setValueAtTime(voice.gainNode.gain.value, now);
                    voice.gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);

                    setTimeout(() => {
                        if (voice.oscillators) {
                            voice.oscillators.forEach(osc => {
                                osc.stop();
                                osc.disconnect();
                            });
                        }
                        if (voice.gainNode) voice.gainNode.disconnect();
                        if (voice.filter) voice.filter.disconnect();
                        if (voice.fmOsc) {
                            voice.fmOsc.stop();
                            voice.fmOsc.disconnect();
                        }
                        if (voice.fmGain) voice.fmGain.disconnect();
                        if (voice.noiseOsc) {
                            voice.noiseOsc.stop();
                            voice.noiseOsc.disconnect();
                        }
                        if (voice.noiseGain) voice.noiseGain.disconnect();
                        if (voice.lfo) {
                            voice.lfo.stop();
                            voice.lfo.disconnect();
                        }
                        if (voice.lfoGain) voice.lfoGain.disconnect();
                    }, releaseTime * 1000);
                }

                delete SynthState.activeVoices[note];
                SynthState.activeNotes.delete(note);

                const keyElement = document.querySelector(`.key[data-note="${note}"]`);
                if (keyElement) keyElement.classList.remove('active');
            },
            stopAllNotes: function (isArpeggiator = false) {
                if (SynthState.arpeggiator.isOn && !isArpeggiator) {
                    Arpeggiator.stop();
                    return;
                }
                SynthState.activeNotes.forEach(note => {
                    if (SynthState.activeVoices[note]) {
                        this.release(note, true);
                    }
                });
                SynthState.activeNotes.clear();
                const keys = document.querySelectorAll('.key.active');
                keys.forEach(key => key.classList.remove('active'));
            }
        };

        // Add this new object right after the Voice object
        const StringVoice = {
            create(note) {
                if (!Synth.audioContext) return null;
                const ctx = Synth.audioContext;
                const frequency = TuningSystem.noteToFreq(note);
                const now = ctx.currentTime;

                // Create main oscillator bank for piano tone
                const oscs = [];
                const gains = [];
                const freqMultipliers = [1, 2, 4]; // Fundamental and harmonics
                const gainValues = [1, 0.6, 0.3];  // Relative volumes

                for (let i = 0; i < freqMultipliers.length; i++) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();

                    osc.type = 'triangle';  // Base tone
                    osc.frequency.value = frequency * freqMultipliers[i];
                    gain.gain.value = gainValues[i] * 0.2;

                    osc.connect(gain);
                    oscs.push(osc);
                    gains.push(gain);
                }

                // Attack noise for hammer sound
                const attackOsc = ctx.createOscillator();
                const attackGain = ctx.createGain();
                attackOsc.type = 'sawtooth';  // Changed from 'white' to 'sawtooth'
                attackGain.gain.value = 0;
                attackOsc.connect(attackGain);

                // Main gain node
                const mainGain = ctx.createGain();
                mainGain.gain.value = 0;

                // Filter for warmth
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 5000;
                filter.Q.value = 0.5;

                // Connect everything
                gains.forEach(g => g.connect(filter));
                attackGain.connect(filter);
                filter.connect(mainGain);
                mainGain.connect(Synth.compressor);

                // Start all oscillators
                oscs.forEach(osc => osc.start(now));
                attackOsc.start(now);

                // Add release method to the voice
                const release = (releaseTime) => {
                    const now = ctx.currentTime;
                    mainGain.gain.cancelScheduledValues(now);
                    mainGain.gain.setValueAtTime(mainGain.gain.value, now);
                    mainGain.gain.exponentialRampToValueAtTime(0.001, now + releaseTime);

                    // Cleanup after release
                    setTimeout(() => {
                        oscs.forEach(osc => {
                            osc.stop();
                            osc.disconnect();
                        });
                        gains.forEach(gain => gain.disconnect());
                        attackOsc.stop();
                        attackOsc.disconnect();
                        attackGain.disconnect();
                        filter.disconnect();
                        mainGain.disconnect();
                    }, releaseTime * 1000);
                };

                return {
                    oscillators: oscs,
                    gains: gains,
                    attackOsc,
                    attackGain,
                    mainGain,
                    filter,
                    frequency,
                    release,  // Add release method to returned object
                    updateVoice: () => {
                        filter.frequency.value = 5000;
                        gains.forEach((gain, i) => {
                            gain.gain.value = gainValues[i] * 0.2;
                        });
                    }
                };
            }
        };
        Voice.stopAllNotes = Voice.stopAllNotes.bind(Voice);
        // Arpeggiator functionality
        const Arpeggiator = {
            step: 0,
            direction: 1,

            start() {
                if (SynthState.arpeggiator.notes.length === 0) return;
                this.stop();
                this.step = 0;
                this.direction = 1;
                this.playCurrentNote();
                const speed = this.calculateSpeed();
                SynthState.arpeggiator.intervalId = setInterval(() => this.playNextNote(), speed);
            },

            stop() {
                if (SynthState.arpeggiator.intervalId) {
                    clearInterval(SynthState.arpeggiator.intervalId);
                    SynthState.arpeggiator.intervalId = null;
                }
                Voice.stopAllNotes(true);
            },

            calculateSpeed() {
                const clockValue = parseInt(SynthState.controls.arpClock.value);
                const speedValue = parseInt(SynthState.controls.arpSpeed.value);
                // Base speed of 500ms (120 BPM) divided by clock division and multiplied by speed factor
                return (500 / clockValue) * (9 - speedValue);
            },

            updateSpeed() {
                if (SynthState.arpeggiator.isOn && SynthState.arpeggiator.notes.length > 0) {
                    this.stop();
                    this.start();
                }
            },

            addNote(note) {
                if (!SynthState.arpeggiator.notes.includes(note)) {
                    SynthState.arpeggiator.notes.push(note);
                }
                if (SynthState.arpeggiator.isOn && SynthState.arpeggiator.notes.length === 1) {
                    this.start();
                }
            },

            removeNote(note) {
                const index = SynthState.arpeggiator.notes.indexOf(note);
                if (index > -1) {
                    SynthState.arpeggiator.notes.splice(index, 1);
                }
                if (SynthState.arpeggiator.notes.length === 0) {
                    this.stop();
                }
            },

            playNextNote() {
                if (SynthState.arpeggiator.notes.length === 0) {
                    this.stop();
                    return;
                }
                this.step = this.getNextStep();
                this.playCurrentNote();
            },

            playCurrentNote() {
                if (SynthState.arpeggiator.notes.length === 0) return;
                const note = SynthState.arpeggiator.notes[this.step];
                Voice.stopAllNotes(true);
                Voice.play(note, true);
            },

            getNextStep() {
                const { pattern, notes } = SynthState.arpeggiator;
                const notesCount = notes.length;
                switch (pattern) {
                    case 'up':
                        return (this.step + 1) % notesCount;
                    case 'down':
                        return (this.step - 1 + notesCount) % notesCount;
                    case 'upDown':
                        if (this.step === 0) this.direction = 1;
                        else if (this.step === notesCount - 1) this.direction = -1;
                        return (this.step + this.direction + notesCount) % notesCount;
                    case 'random':
                        return Math.floor(Math.random() * notesCount);
                    default:
                        return (this.step + 1) % notesCount;
                }
            },
        };
        // UI related functions
        const UI = {
            createPiano() {
                const piano = document.getElementById('piano');
                piano.innerHTML = '';
                for (let octave = 1; octave < 7; octave++) {
                    SynthConfig.whiteNotes.forEach(note => {
                        const key = document.createElement('div');
                        key.className = 'key';
                        key.dataset.note = note + octave;
                        piano.appendChild(key);
                    });
                }

                const whiteKeys = piano.querySelectorAll('.key');
                let blackKeyIndex = 0;
                whiteKeys.forEach((whiteKey, index) => {
                    if (index % 7 !== 2 && index % 7 !== 6) {
                        const blackKey = document.createElement('div');
                        blackKey.className = 'key black';
                        blackKey.dataset.note = SynthConfig.blackNotes[blackKeyIndex % 5] + (Math.floor(index / 7) + 1);
                        whiteKey.parentNode.insertBefore(blackKey, whiteKey.nextSibling);
                        blackKeyIndex++;
                    }
                });
            },

            toggleVisualizer() {
                this.visualizerEnabled = !this.visualizerEnabled;
                const visualizer = document.getElementById('visualizer');
                const toggleButton = document.getElementById('toggleVisualizer');

                if (this.visualizerEnabled) {
                    visualizer.style.display = 'block';
                    this.updateVisualizer();
                } else {
                    visualizer.style.display = 'none';
                }
            },
            updateCircularControls() {
                document.querySelectorAll('.circular-control input[type="range"]').forEach(input => {
                    const value = parseFloat(input.value);
                    const min = parseFloat(input.min);
                    const max = parseFloat(input.max);
                    const normalizedValue = (value - min) / (max - min);
                    const rotation = normalizedValue * 270 - 135; // Map 0-1 to -135deg to 135deg
                    input.parentNode.style.setProperty('--rotation', `${rotation}deg`);

                    // Update value display
                    const valueSpan = input.parentNode.querySelector('.knob-value');
                    if (valueSpan) {
                        const unit = input.parentNode.dataset.unit || '';
                        const format = input.parentNode.dataset.format || '';
                        valueSpan.textContent = Util.formatValue(value, unit, format);
                    }
                });
            },

            handleCircularControlInteraction(event) {
                const control = event.currentTarget;
                const input = control.querySelector('input[type="range"]');
                let startY, startValue;

                function handleStart(e) {
                    startY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                    startValue = parseFloat(input.value);
                    document.addEventListener('mousemove', handleMove);
                    document.addEventListener('touchmove', handleMove, { passive: false });
                    document.addEventListener('mouseup', handleEnd);
                    document.addEventListener('touchend', handleEnd);
                }

                function handleMove(e) {
                    const currentY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                    const deltaY = startY - currentY;
                    const range = input.max - input.min;
                    const valueChange = (deltaY / 100) * range;
                    let newValue = Math.max(input.min, Math.min(input.max, startValue + valueChange));

                    input.value = newValue;
                    Synth.updateParams();
                    input.dispatchEvent(new Event('input'));
                    e.preventDefault();
                }

                function handleEnd() {
                    document.removeEventListener('mousemove', handleMove);
                    document.removeEventListener('touchmove', handleMove);
                    document.removeEventListener('mouseup', handleEnd);
                    document.removeEventListener('touchend', handleEnd);
                }

                if (event.type === 'mousedown') {
                    handleStart(event);
                } else if (event.type === 'touchstart') {
                    handleStart(event);
                }
            },
            initializeEventListeners() {
                const keys = document.querySelectorAll('.key');
                let isMouseDown = false;
                let lastPlayedNote = null;

                keys.forEach(key => {
                    key.addEventListener('mousedown', (e) => {
                        isMouseDown = true;
                        const note = e.target.dataset.note;
                        Voice.play(note);
                        lastPlayedNote = note;
                    });

                    key.addEventListener('mouseenter', (e) => {
                        if (isMouseDown) {
                            const note = e.target.dataset.note;
                            if (note !== lastPlayedNote) {
                                Voice.release(lastPlayedNote);
                                Voice.play(note);
                                lastPlayedNote = note;
                            }
                        }
                    });

                    key.addEventListener('mouseleave', (e) => {
                        if (isMouseDown) {
                            const note = e.target.dataset.note;
                            Voice.release(note);
                        }
                    });
                });

                document.addEventListener('mouseup', () => {
                    if (isMouseDown) {
                        Voice.release(lastPlayedNote);
                        isMouseDown = false;
                        lastPlayedNote = null;
                    }
                });

                document.getElementById('piano').addEventListener('selectstart', (e) => e.preventDefault());

                // Control event listeners
                Object.entries(SynthState.controls).forEach(([key, control]) => {
                    if (!control || !control.addEventListener) return;
                    if (control.type === 'checkbox' || control.tagName === 'SELECT') {
                        control.addEventListener('change', () => Synth.updateParams(key));
                    } else {
                        control.addEventListener('input', () => Synth.updateParams(key));
                    }
                });

                // Arpeggiator controls
                SynthState.controls.arpToggle.addEventListener('change', (e) => {
                    SynthState.arpeggiator.isOn = e.target.checked;
                    if (SynthState.arpeggiator.isOn) {
                        if (SynthState.arpeggiator.notes.length > 0) {
                            Arpeggiator.start();
                        }
                    } else {
                        Arpeggiator.stop();
                    }
                });

                SynthState.controls.masterVolume.addEventListener('input', () => Synth.updateParams('masterVolume'));
                SynthState.controls.masterReverb.addEventListener('input', () => Synth.updateParams('masterReverb'));
                SynthState.controls.masterDelay.addEventListener('input', () => Synth.updateParams('masterDelay'));
                SynthState.controls.masterLowEQ.addEventListener('input', () => Synth.updateParams('masterLowEQ'));
                SynthState.controls.masterMidEQ.addEventListener('input', () => Synth.updateParams('masterMidEQ'));
                SynthState.controls.masterHighEQ.addEventListener('input', () => Synth.updateParams('masterHighEQ'));
                SynthState.controls.filterToggle.addEventListener('change', () => Synth.updateParams('filterToggle'));
                SynthState.controls.arpSpeed.addEventListener('input', Arpeggiator.updateSpeed);
                SynthState.controls.arpClock.addEventListener('change', Arpeggiator.updateSpeed);
                SynthState.controls.arpPattern.addEventListener('change', Arpeggiator.updateSpeed);
                SynthState.controls.noiseToggle.addEventListener('change', () => Synth.updateParams('noiseToggle'));
                SynthState.controls.noiseAmount.addEventListener('input', () => Synth.updateParams('noiseAmount'));
                SynthState.controls.lfoToggle.addEventListener('change', () => Synth.updateParams('lfoToggle'));
                SynthState.controls.lfoRate.addEventListener('input', () => Synth.updateParams('lfoRate'));
                SynthState.controls.lfoAmount.addEventListener('input', () => Synth.updateParams('lfoAmount'));
                SynthState.controls.unison.addEventListener('input', () => Synth.updateParams('unison'));
                SynthState.controls.detune.addEventListener('input', () => Synth.updateParams('detune'));
                SynthState.controls.waveform.addEventListener('change', () => Synth.updateParams('waveform'));
                SynthState.controls.pitchBendWheel.addEventListener('input', (e) => {
                    const bend = parseFloat(e.target.value);
                    Synth.updatePitchBend(bend);
                });

                SynthState.controls.pitchBendRange.addEventListener('input', (e) => {
                    const range = parseInt(e.target.value);
                    Synth.updatePitchBendRange(range);
                });

                SynthState.controls.pitchBendWheel.addEventListener('mouseup', (e) => {
                    e.target.value = 0;
                    Synth.updatePitchBend(0);
                });

                SynthState.controls.pitchBendWheel.addEventListener('touchend', (e) => {
                    e.target.value = 0;
                    Synth.updatePitchBend(0);
                });

                // Add event listener for the new toggle
                SynthState.controls.whiteKeysOnlyToggle = document.getElementById('whiteKeysOnlyToggle');
                SynthState.controls.whiteKeysOnlyToggle.addEventListener('change', (e) => {
                    SynthState.whiteKeysOnly = e.target.checked;
                });

                // Keyboard controls
                document.addEventListener('keydown', (event) => {
                    let key = event.key.toLowerCase();
                    const location = event.location;

                    // Handle numpad keys
                    if (location === KeyboardEvent.DOM_KEY_LOCATION_NUMPAD) {
                        if (key === '.') {
                            key = 'numpad.';
                        } else if (key === 'enter') {
                            key = 'numpadenter';
                        } else {
                            key = 'numpad' + key;
                        }
                    } else if (key === 'numlock') {
                        key = 'numpad';
                    }

                    const keyboardMap = SynthState.whiteKeysOnly ? SynthConfig.whiteKeysOnlyMap : SynthConfig.keyboardMap;
                    const note = keyboardMap[key];
                    if (note && !event.repeat) {
                        Voice.play(note);
                        event.preventDefault();
                    }
                });

                document.addEventListener('keyup', (event) => {
                    let key = event.key.toLowerCase();
                    const location = event.location;

                    // Handle numpad keys
                    if (location === KeyboardEvent.DOM_KEY_LOCATION_NUMPAD) {
                        if (key === '.') {
                            key = 'numpad.';
                        } else if (key === 'enter') {
                            key = 'numpadenter';
                        } else {
                            key = 'numpad' + key;
                        }
                    } else if (key === 'numlock') {
                        key = 'numpad';
                    }

                    const keyboardMap = SynthState.whiteKeysOnly ? SynthConfig.whiteKeysOnlyMap : SynthConfig.keyboardMap;
                    const note = keyboardMap[key];
                    if (note) {
                        Voice.release(note);
                        event.preventDefault();
                    }
                });
                window.addEventListener('blur', () => Voice.stopAllNotes());
                window.addEventListener('resize', this.updateVisualizer);

                document.querySelectorAll('.circular-control').forEach(control => {
                    control.addEventListener('mousedown', this.handleCircularControlInteraction);
                    control.addEventListener('touchstart', this.handleCircularControlInteraction, { passive: false });
                });

                const toggleVisualizerButton = document.getElementById('toggleVisualizer');
                toggleVisualizerButton.addEventListener('click', () => Synth.toggleVisualizer());

                // Visualizer mode selector
                document.getElementById('visualizerMode').addEventListener('change', (e) => {
                    Synth.visualizerMode = e.target.value;
                });

                // Initialize Preset controls
                PresetManager.updatePresetSelect();

                document.getElementById('presetSelect').addEventListener('change', (e) => {
                    const value = e.target.value;
                    if (!value) return;

                    const [type, name] = value.split(':');
                    let settings;

                    if (type === 'factory') {
                        settings = PresetManager.getFactoryPresets()[name];
                    } else {
                        settings = PresetManager.loadPreset(name);
                    }

                    if (settings) {
                        PresetManager.applySettings(settings);
                    }
                });

                document.getElementById('savePresetButton').addEventListener('click', () => {
                    const name = prompt('Enter preset name:');
                    if (name && name.trim()) {
                        const settings = PresetManager.getCurrentSettings();
                        if (PresetManager.savePreset(name.trim(), settings)) {
                            PresetManager.updatePresetSelect();
                            document.getElementById('presetSelect').value = 'user:' + name.trim();
                        }
                    }
                });

                document.getElementById('deletePresetButton').addEventListener('click', () => {
                    const select = document.getElementById('presetSelect');
                    const value = select.value;

                    if (!value || !value.startsWith('user:')) {
                        alert('Please select a user preset to delete');
                        return;
                    }

                    const name = value.replace('user:', '');
                    if (confirm(`Delete preset "${name}"?`)) {
                        PresetManager.deletePreset(name);
                        PresetManager.updatePresetSelect();
                    }
                });

                // MIDI enable button (opt-in, no auto-request)
                document.getElementById('midiEnableButton').addEventListener('click', () => {
                    MIDIHandler.init();
                });

                // Add tuning preset handler
                SynthState.controls.tuningPreset.addEventListener('change', async (e) => {
                    const selectedTuning = e.target.value;
                    if (!selectedTuning) {
                        // Default tuning selected
                        TuningSystem.resetToDefaultTuning();
                        return;
                    }

                    // Define tuning URLs
                    const tuningUrls = {
                        '17-tone': {
                            primary: 'https://magic.decentralized-content.com/ipfs/bafybeihi7nw54z2avcns57c2jzafivikep5qts2ojt2rdfv4b3t26onbu4?filename=17-tone%20Scale.tun',
                            backup: 'https://ipfs.oversas.org/ipfs/QmWQJqerjRcjhF3i7oPtRU9AUDy6Krq2mxZygySbQfiYpJ?filename=17-tone%20Scale.tun'
                        },
                        '13-tone': {
                            primary: 'https://magic.decentralized-content.com/ipfs/bafybeig3pxitw2dmiozgrqjc5r3wp2i3izri476v5ckc4nzncl5a4cyyeu',
                            backup: 'https://ipfs.oversas.org/ipfs/bafybeig3pxitw2dmiozgrqjc5r3wp2i3izri476v5ckc4nzncl5a4cyyeu'
                        },
                        '24-tone': {
                            primary: 'https://magic.decentralized-content.com/ipfs/bafybeieocuhzmzjytzccmsog34hcnaf5t234ifqvsgz5zvfg6dtqjnpmj4',
                            backup: 'https://ipfs.oversas.org/ipfs/bafybeieocuhzmzjytzccmsog34hcnaf5t234ifqvsgz5zvfg6dtqjnpmj4'
                        }
                    };

                    const selectedUrls = tuningUrls[selectedTuning];
                    if (!selectedUrls) {
                        console.error('Unknown tuning selected');
                        return;
                    }

                    try {
                        const response = await fetch(selectedUrls.primary);
                        if (!response.ok) {
                            throw new Error('Failed to fetch tuning file');
                        }

                        const tuningContent = await response.text();
                        const frequencies = TuningSystem.parseTunFile(tuningContent, selectedTuning);  // Pass the selected tuning type

                        if (!frequencies) {
                            console.error('Failed to parse tuning file');
                            return;
                        }

                        TuningSystem.importTuning(frequencies);

                        // Update all active voices with new tuning
                        Object.entries(SynthState.activeVoices).forEach(([note, voice]) => {
                            const frequency = TuningSystem.noteToFreq(note);
                            const now = Synth.audioContext.currentTime;
                            voice.oscillators.forEach(osc => {
                                osc.frequency.setValueAtTime(frequency, now);
                            });
                            if (voice.fmOsc) {
                                voice.fmOsc.frequency.setValueAtTime(frequency * 2, now);
                            }
                        });

                    } catch (error) {
                        console.error('Error loading tuning preset:', error);
                        // Try backup URL if primary fails
                        try {
                            const backupResponse = await fetch(selectedUrls.backup);
                            if (!backupResponse.ok) {
                                throw new Error('Failed to fetch tuning file from backup');
                            }

                            const tuningContent = await backupResponse.text();
                            const frequencies = TuningSystem.parseTunFile(tuningContent, selectedTuning);

                            if (!frequencies) {
                                console.error('Failed to parse tuning file from backup');
                                return;
                            }

                            TuningSystem.importTuning(frequencies);

                            // Update all active voices with new tuning
                            Object.entries(SynthState.activeVoices).forEach(([note, voice]) => {
                                const frequency = TuningSystem.noteToFreq(note);
                                const now = Synth.audioContext.currentTime;
                                voice.oscillators.forEach(osc => {
                                    osc.frequency.setValueAtTime(frequency, now);
                                });
                                if (voice.fmOsc) {
                                    voice.fmOsc.frequency.setValueAtTime(frequency * 2, now);
                                }
                            });

                        } catch (backupError) {
                            console.error('Error loading tuning preset from backup:', backupError);
                            alert('Failed to load tuning preset. Please try again later.');
                            e.target.value = ''; // Reset to default
                            TuningSystem.resetToDefaultTuning();
                        }
                    }
                });
            }
        };

        // Main Synth object
        const Synth = {
            recorder: null,
            recordedChunks: [],
            recordedNotes: [],
            recordingStartTime: 0,
            audioContext: null,
            compressor: null,
            playbackAudio: null,
            playbackSource: null,
            masterReverb: null,
            masterDelay: null,
            masterLowEQ: null,
            masterMidEQ: null,
            masterHighEQ: null,
            visualizerEnabled: true,
            visualizerMode: 'lissajous',

            initialize() {
                // Show piano immediately behind modal
                UI.createPiano();

                const startButton = document.getElementById('startButton');
                const startModal = document.getElementById('startModal');
                const exportWavButton = document.getElementById('exportWavButton');
                exportWavButton.addEventListener('click', () => this.exportWav());

                // Initialize tuning controls early
                SynthState.controls.tuningPreset = document.getElementById('tuningPreset');
                const applyTuningButton = document.getElementById('applyTuning');
                const resetTuningButton = document.getElementById('resetTuning');
                const tuningFileInput = document.getElementById('tuningFile');

                // Make sure the apply button starts disabled
                if (applyTuningButton) {
                    applyTuningButton.disabled = true;
                }

                // Set up tuning file input handler
                if (tuningFileInput) {
                    tuningFileInput.addEventListener('change', (event) => {
                        const file = event.target.files[0];
                        if (!file) {
                            console.log('No file selected');
                            applyTuningButton.disabled = true;
                            return;
                        }

                        const reader = new FileReader();
                        reader.onload = (e) => {
                            loadedTuningContent = e.target.result;
                            console.log('Tuning file loaded:', loadedTuningContent.substring(0, 100) + '...');
                            applyTuningButton.disabled = false;
                        };
                        reader.onerror = (error) => {
                            console.error('Error reading file:', error);
                            applyTuningButton.disabled = true;
                        };
                        reader.readAsText(file);
                    });
                }

                startButton.addEventListener('click', () => {
                    this.initAudioContext();
                    startModal.style.display = 'none';
                    this.start();
                });

                const recordButton = document.getElementById('recordButton');
                const stopButton = document.getElementById('stopButton');
                const saveButton = document.getElementById('saveButton');
                const loadButton = document.getElementById('loadButton');
                const playButton = document.getElementById('playButton');

                recordButton.addEventListener('click', () => this.startRecording());
                stopButton.addEventListener('click', () => this.stopRecording());
                saveButton.addEventListener('click', () => this.saveRecording());
                loadButton.addEventListener('click', () => this.loadRecording());
                playButton.addEventListener('click', () => this.playRecording());

                // Initialize pitch bend controls
                SynthState.controls.pitchBendWheel = document.getElementById('pitchBendWheel');
                SynthState.controls.pitchBendRange = document.getElementById('pitchBendRange');
            },
            start() {
                console.log('Synth start initiated...');

                // Initialize all controls
                SynthState.controls = {
                    synthMode: document.getElementById('synthMode'),
                    whiteKeysOnlyToggle: document.getElementById('whiteKeysOnlyToggle'),
                    masterVolume: document.getElementById('masterVolume'),
                    masterReverb: document.getElementById('masterReverb'),
                    masterDelay: document.getElementById('masterDelay'),
                    masterLowEQ: document.getElementById('masterLowEQ'),
                    masterMidEQ: document.getElementById('masterMidEQ'),
                    masterHighEQ: document.getElementById('masterHighEQ'),
                    waveform: document.getElementById('waveform'),
                    unison: document.getElementById('unison'),
                    detune: document.getElementById('detune'),
                    fmAmount: document.getElementById('fmAmount'),
                    filterToggle: document.getElementById('filterToggle'),
                    filterType: document.getElementById('filterType'),
                    filterCutoff: document.getElementById('filterCutoff'),
                    filterResonance: document.getElementById('filterResonance'),
                    filterEnvAmount: document.getElementById('filterEnvAmount'),
                    attack: document.getElementById('attack'),
                    decay: document.getElementById('decay'),
                    sustain: document.getElementById('sustain'),
                    release: document.getElementById('release'),
                    lfoRate: document.getElementById('lfoRate'),
                    lfoAmount: document.getElementById('lfoAmount'),
                    noiseAmount: document.getElementById('noiseAmount'),
                    arpToggle: document.getElementById('arpToggle'),
                    arpPattern: document.getElementById('arpPattern'),
                    arpSpeed: document.getElementById('arpSpeed'),
                    arpClock: document.getElementById('arpClock'),
                    fmToggle: document.getElementById('fmToggle'),
                    lfoToggle: document.getElementById('lfoToggle'),
                    noiseToggle: document.getElementById('noiseToggle'),
                    pitchBendWheel: document.getElementById('pitchBendWheel'),
                    pitchBendRange: document.getElementById('pitchBendRange'),
                    tuningPreset: document.getElementById('tuningPreset'),
                    tuningFile: document.getElementById('tuningFile'),
                    applyTuning: document.getElementById('applyTuning'),
                    resetTuning: document.getElementById('resetTuning')
                };

                // Set initial states
                SynthState.controls.fmToggle.checked = SynthState.fmEnabled;
                SynthState.controls.lfoToggle.checked = SynthState.lfoEnabled;
                SynthState.controls.noiseToggle.checked = SynthState.noiseEnabled;
                SynthState.controls.applyTuning.disabled = true;

                console.log('Setting up tuning controls...');

                // Setup tuning file handler
                SynthState.controls.tuningFile.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (!file) {
                        console.log('No file selected');
                        SynthState.controls.applyTuning.disabled = true;
                        return;
                    }

                    console.log('File selected:', file.name);
                    loadedFileName = file.name;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        loadedTuningContent = e.target.result;
                        console.log('Tuning file loaded:', loadedTuningContent.substring(0, 100) + '...');
                        SynthState.controls.applyTuning.disabled = false;
                    };
                    reader.onerror = (e) => {
                        console.error('Error reading file:', e);
                        SynthState.controls.applyTuning.disabled = true;
                    };
                    reader.readAsText(file);
                });

                // Setup apply tuning handler
                SynthState.controls.applyTuning.addEventListener('click', () => {
                    console.log('Apply button clicked!');

                    if (!loadedTuningContent) {
                        console.error('No tuning content to apply');
                        return;
                    }

                    console.log('Processing tuning file...');

                    // Parse and apply the tuning
                    const frequencies = TuningSystem.parseTunFile(loadedTuningContent);
                    if (!frequencies) {
                        console.error('Failed to parse frequencies from file');
                        return;
                    }

                    console.log('Parsed frequencies preview:', frequencies.slice(60, 72));

                    // Import the tuning
                    TuningSystem.importTuning(frequencies);

                    console.log('Tuning system state after import:');
                    console.log('- isCustomTuning:', TuningSystem.isCustomTuning);
                    console.log('- Has frequencies:', TuningSystem.frequencies.some(f => f !== null));

                    // Update all active voices
                    Object.entries(SynthState.activeVoices).forEach(([note, voice]) => {
                        const frequency = TuningSystem.noteToFreq(note);
                        console.log(`Updating voice ${note} to ${frequency}Hz`);
                        const now = Synth.audioContext.currentTime;

                        voice.oscillators.forEach(osc => {
                            osc.frequency.setValueAtTime(frequency, now);
                        });

                        if (voice.fmOsc) {
                            voice.fmOsc.frequency.setValueAtTime(frequency * 2, now);
                        }
                    });

                    console.log('Tuning update complete!');
                });

                // Setup reset tuning handler
                SynthState.controls.resetTuning.addEventListener('click', () => {
                    console.log('Resetting to default tuning');
                    TuningSystem.resetToDefaultTuning();
                    loadedTuningContent = null;
                    loadedFileName = null;
                    SynthState.controls.applyTuning.disabled = true;
                    SynthState.controls.tuningFile.value = '';

                    // Reset all active voices
                    Object.entries(SynthState.activeVoices).forEach(([note, voice]) => {
                        const frequency = TuningSystem.noteToFreq(note);
                        const now = Synth.audioContext.currentTime;
                        voice.oscillators.forEach(osc => {
                            osc.frequency.setValueAtTime(frequency, now);
                        });
                        if (voice.fmOsc) {
                            voice.fmOsc.frequency.setValueAtTime(frequency * 2, now);
                        }
                    });
                });

                // Setup pitch bend range controls
                if (SynthState.controls.pitchBendRange === null) {
                    console.error('pitchBendRange element not found');
                } else {
                    // Initialize pitch bend range
                    this.updatePitchBendRange(parseInt(SynthState.controls.pitchBendRange.value) || 2);
                }

                // Setup range increment/decrement controls
                document.getElementById('incrementRange').addEventListener('click', () => this.incrementPitchBendRange());
                document.getElementById('decrementRange').addEventListener('click', () => this.decrementPitchBendRange());

                // Setup initial control states
                this.updateMasterVolume();
                this.updateMasterReverb();
                this.updateMasterDelay();
                this.updateMasterEQ();

                // Initialize UI
                UI.createPiano();
                UI.initializeEventListeners();
                this.updateVisualizer();
                this.updateParams();

                // Initialize Wavetable Editor
                WavetableEditor.init();
                WavetableEditor.apply(); // Apply default wavetable

                // Synth mode change handler - show/hide wavetable controls
                SynthState.controls.synthMode.addEventListener('change', (e) => {
                    const mode = e.target.value;
                    document.getElementById('waveformControl').style.display = mode === 'waveform' ? 'block' : 'none';
                    document.getElementById('wavetableControls').style.display = mode === 'wavetable' ? 'block' : 'none';
                });

                // Wavetable position change handler
                const wavetablePositionControl = document.getElementById('wavetablePosition');
                if (wavetablePositionControl) {
                    wavetablePositionControl.addEventListener('input', (e) => {
                        SynthState.wavetable.position = parseFloat(e.target.value);
                        WavetableEditor.updatePeriodicWave();
                        // Update active voices with new wavetable
                        Object.values(SynthState.activeVoices).forEach(voice => {
                            if (voice.updateVoice) voice.updateVoice();
                        });
                    });
                }

                console.log('Synth initialization complete');
            },
            initAudioContext() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGainNode = this.audioContext.createGain();
                this.masterGainNode.gain.setValueAtTime(0.7, this.audioContext.currentTime);

                this.masterReverb = this.createReverbEffect();
                const delayEffect = this.createDelayEffect();
                this.masterDelay = delayEffect.delayNode;
                this.delayFeedback = delayEffect.feedbackGain;
                this.masterLowEQ = this.audioContext.createBiquadFilter();
                this.masterMidEQ = this.audioContext.createBiquadFilter();
                this.masterHighEQ = this.audioContext.createBiquadFilter();

                this.compressor = this.audioContext.createDynamicsCompressor();
                this.compressor.threshold.setValueAtTime(-24, this.audioContext.currentTime);
                this.compressor.knee.setValueAtTime(30, this.audioContext.currentTime);
                this.compressor.ratio.setValueAtTime(12, this.audioContext.currentTime);
                this.compressor.attack.setValueAtTime(0.003, this.audioContext.currentTime);
                this.compressor.release.setValueAtTime(0.25, this.audioContext.currentTime);

                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 2048;

                // Create dry/wet gains for reverb and delay
                this.reverbDry = this.audioContext.createGain();
                this.reverbWet = this.audioContext.createGain();
                this.delayDry = this.audioContext.createGain();
                this.delayWet = this.audioContext.createGain();

                // Connect the nodes
                this.compressor.connect(this.masterLowEQ);
                this.masterLowEQ.connect(this.masterMidEQ);
                this.masterMidEQ.connect(this.masterHighEQ);
                this.masterHighEQ.connect(this.reverbDry);
                this.masterHighEQ.connect(this.reverbWet);
                this.reverbWet.connect(this.masterReverb);
                this.masterReverb.connect(this.delayDry);
                this.reverbDry.connect(this.delayDry);
                this.delayDry.connect(this.delayWet);
                this.delayWet.connect(this.masterDelay);
                this.masterDelay.connect(this.delayFeedback);
                this.delayFeedback.connect(this.masterDelay);
                this.masterDelay.connect(this.masterGainNode);
                this.delayDry.connect(this.masterGainNode);
                this.masterGainNode.connect(this.analyser);
                this.analyser.connect(this.audioContext.destination);
                // Start the visualizer
                this.updateVisualizer();

                // Set up EQ filters
                this.masterLowEQ.type = 'lowshelf';
                this.masterLowEQ.frequency.value = 200;
                this.masterMidEQ.type = 'peaking';
                this.masterMidEQ.frequency.value = 1000;
                this.masterMidEQ.Q.value = 1;
                this.masterHighEQ.type = 'highshelf';
                this.masterHighEQ.frequency.value = 3000;

                // Initialize delay
                this.masterDelay.delayTime.value = 0.5;
                this.delayWet.gain.value = 0;
                this.delayDry.gain.value = 1;

                // Initialize reverb
                this.reverbWet.gain.value = 0;
                this.reverbDry.gain.value = 1;
            },

            createReverbEffect() {
                const reverbNode = this.audioContext.createConvolver();
                const length = this.audioContext.sampleRate * 4; // 4 seconds
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                const impulseL = impulse.getChannelData(0);
                const impulseR = impulse.getChannelData(1);

                for (let i = 0; i < length; i++) {
                    const t = i / this.audioContext.sampleRate;
                    const decay = Math.exp(-t * 3); // Adjust decay rate
                    impulseL[i] = (Math.random() * 2 - 1) * decay;
                    impulseR[i] = (Math.random() * 2 - 1) * decay;
                }

                reverbNode.buffer = impulse;
                return reverbNode;
            },

            createDelayEffect() {
                const delayNode = this.audioContext.createDelay(5.0);
                const feedbackGain = this.audioContext.createGain();

                delayNode.delayTime.value = 0.5; // 500ms delay
                feedbackGain.gain.value = 0.3; // 30% feedback

                delayNode.connect(feedbackGain);
                feedbackGain.connect(delayNode);

                return { delayNode, feedbackGain };
            },

            incrementPitchBendRange() {
                const currentRange = parseInt(SynthState.controls.pitchBendRange.value) || 2;
                const newRange = Math.min(24, currentRange + 1); // Max range is 24 semitones
                SynthState.controls.pitchBendRange.value = newRange;
                this.updatePitchBendRange(newRange);
            },

            decrementPitchBendRange() {
                const currentRange = parseInt(SynthState.controls.pitchBendRange.value) || 2;
                const newRange = Math.max(1, currentRange - 1); // Min range is 1 semitone
                SynthState.controls.pitchBendRange.value = newRange;
                this.updatePitchBendRange(newRange);
            },

            updatePitchBendRange(range) {
                const clampedRange = Math.max(1, Math.min(24, range)); // Clamp range between 1 and 24 semitones
                Object.values(SynthState.activeVoices).forEach(voice => {
                    voice.pitchBend.range = clampedRange;
                    voice.updatePitchBend(voice.pitchBend.bend);
                });
            },

            updatePitchBend(bend) {
                Object.values(SynthState.activeVoices).forEach(voice => {
                    if (voice.updatePitchBend) {
                        voice.updatePitchBend(bend);
                    }
                });
            },

            updateMasterReverb() {
                const reverbAmount = parseFloat(SynthState.controls.masterReverb.value);
                const dryAmount = Math.cos(reverbAmount * 0.5 * Math.PI);
                const wetAmount = Math.sin(reverbAmount * 0.5 * Math.PI);

                this.reverbWet.gain.setTargetAtTime(wetAmount, this.audioContext.currentTime, 0.01);
                this.reverbDry.gain.setTargetAtTime(dryAmount, this.audioContext.currentTime, 0.01);
            },

            updateMasterDelay() {
                const delayAmount = parseFloat(SynthState.controls.masterDelay.value);
                const dryAmount = Math.cos(delayAmount * 0.5 * Math.PI);
                const wetAmount = Math.sin(delayAmount * 0.5 * Math.PI);

                this.delayWet.gain.setTargetAtTime(wetAmount, this.audioContext.currentTime, 0.01);
                this.delayDry.gain.setTargetAtTime(dryAmount, this.audioContext.currentTime, 0.01);

                const delayTime = 0.1 + (delayAmount * 0.9);
                this.masterDelay.delayTime.setTargetAtTime(delayTime, this.audioContext.currentTime, 0.01);

                const feedback = delayAmount * 0.7;
                this.delayFeedback.gain.setTargetAtTime(feedback, this.audioContext.currentTime, 0.01);
            },

            updateMasterEQ() {
                const lowGain = parseFloat(SynthState.controls.masterLowEQ.value);
                const midGain = parseFloat(SynthState.controls.masterMidEQ.value);
                const highGain = parseFloat(SynthState.controls.masterHighEQ.value);

                this.masterLowEQ.gain.setTargetAtTime(lowGain, this.audioContext.currentTime, 0.01);
                this.masterMidEQ.gain.setTargetAtTime(midGain, this.audioContext.currentTime, 0.01);
                this.masterHighEQ.gain.setTargetAtTime(highGain, this.audioContext.currentTime, 0.01);
            },
            updateParams(changedParam) {
                if (changedParam === 'masterReverb') {
                    this.updateMasterReverb();
                } else if (changedParam === 'masterDelay') {
                    this.updateMasterDelay();
                } else if (changedParam === 'masterLowEQ' || changedParam === 'masterMidEQ' || changedParam === 'masterHighEQ') {
                    this.updateMasterEQ();
                } else if (changedParam === 'pitchBendWheel') {
                    this.updatePitchBend(parseFloat(SynthState.controls.pitchBendWheel.value));
                } else if (changedParam === 'pitchBendRange') {
                    this.updatePitchBendRange(parseInt(SynthState.controls.pitchBendRange.value));
                } else if (changedParam === 'masterVolume') {
                    this.updateMasterVolume();
                } else if (changedParam === 'unison' || changedParam === 'detune' || changedParam === 'waveform') {
                    Object.values(SynthState.activeVoices).forEach(voice => voice.updateVoice());
                } else if (changedParam === 'filterToggle') {
                    SynthState.filterEnabled = SynthState.controls.filterToggle.checked;
                } else if (changedParam === 'noiseToggle') {
                    SynthState.noiseEnabled = SynthState.controls.noiseToggle.checked;
                } else if (changedParam === 'lfoToggle') {
                    SynthState.lfoEnabled = SynthState.controls.lfoToggle.checked;
                }

                SynthState.filterSettings.type = SynthState.controls.filterType.value;
                // Use logarithmic scale for filter cutoff (more musical control)
                const cutoffValue = parseFloat(SynthState.controls.filterCutoff.value);
                const minFreq = 20, maxFreq = 20000;
                // Convert linear slider to logarithmic frequency
                const normalizedCutoff = (cutoffValue - minFreq) / (maxFreq - minFreq);
                SynthState.filterSettings.frequency = minFreq * Math.pow(maxFreq / minFreq, normalizedCutoff);
                SynthState.filterSettings.Q = parseFloat(SynthState.controls.filterResonance.value);
                SynthState.fmEnabled = SynthState.controls.fmToggle.checked;

                Object.values(SynthState.activeVoices).forEach(voice => {
                    if (voice.updateVoice) voice.updateVoice();
                });

                UI.updateCircularControls();
            },

            updateMasterVolume() {
                const volume = parseFloat(SynthState.controls.masterVolume.value);
                if (this.masterGainNode) {
                    this.masterGainNode.gain.setTargetAtTime(volume, this.audioContext.currentTime, 0.01);
                }
            },

            startRecording() {
                this.recordedChunks = [];
                this.recordedNotes = [];
                this.recordingStartTime = this.audioContext.currentTime;
                const stream = this.createMediaStreamFromAudioGraph();
                this.recorder = new MediaRecorder(stream);
                this.recorder.ondataavailable = (e) => this.recordedChunks.push(e.data);
                this.recorder.start();
                document.getElementById('recordButton').disabled = true;
                document.getElementById('stopButton').disabled = false;
                document.getElementById('playButton').disabled = true;
                document.getElementById('saveButton').disabled = true;
                document.getElementById('exportWavButton').disabled = true;
            },

            stopRecording() {
                this.recorder.stop();
                document.getElementById('recordButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
                document.getElementById('playButton').disabled = false;
                document.getElementById('saveButton').disabled = false;
                document.getElementById('exportWavButton').disabled = false;
            },

            playRecording() {
                if (this.playbackAudio) {
                    this.playbackAudio.currentTime = 0;
                } else if (this.recordedChunks.length > 0) {
                    const blob = new Blob(this.recordedChunks, { type: 'audio/wav' });
                    const audioURL = URL.createObjectURL(blob);
                    this.playbackAudio = new Audio(audioURL);
                } else {
                    console.log('No recording to play');
                    return;
                }

                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }

                if (!this.playbackSource) {
                    this.playbackSource = this.audioContext.createMediaElementSource(this.playbackAudio);
                    this.playbackSource.connect(this.compressor);
                }

                this.playbackAudio.play().then(() => {
                    this.animatePlayback();
                    UI.updateVisualizer();
                }).catch(error => {
                    console.error('Error playing audio:', error);
                });
            },

            stopPlayback() {
                if (this.playbackAudio) {
                    this.playbackAudio.pause();
                    this.playbackAudio.currentTime = 0;
                }
                document.querySelectorAll('.key.active').forEach(key => key.classList.remove('active'));
            },

            updateVisualizer() {
                if (!this.analyser || !this.visualizerEnabled) return;

                const visualizer = document.getElementById('visualizer');
                const width = visualizer.offsetWidth;
                const height = visualizer.offsetHeight;

                // Set canvas resolution (not CSS size)
                visualizer.width = width * window.devicePixelRatio;
                visualizer.height = height * window.devicePixelRatio;

                const ctx = visualizer.getContext('2d');
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

                const bufferLength = this.analyser.frequencyBinCount;
                const timeData = new Uint8Array(bufferLength);

                const synth = this;

                // Oscilloscope
                const drawOscilloscope = () => {
                    synth.analyser.getByteTimeDomainData(timeData);

                    ctx.fillStyle = 'rgba(26, 26, 26, 0.3)';
                    ctx.fillRect(0, 0, width, height);

                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#00ff9d';
                    ctx.beginPath();

                    const sliceWidth = width / bufferLength;
                    let x = 0;

                    for (let i = 0; i < bufferLength; i++) {
                        const v = timeData[i] / 128.0;
                        const y = v * height / 2;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        x += sliceWidth;
                    }

                    ctx.stroke();
                };

                // Lissajous
                const drawLissajous = () => {
                    synth.analyser.getByteTimeDomainData(timeData);

                    ctx.fillStyle = 'rgba(26, 26, 26, 0.08)';
                    ctx.fillRect(0, 0, width, height);

                    const centerX = width / 2;
                    const centerY = height / 2;
                    const scale = height * 0.45;

                    ctx.strokeStyle = '#00ff9d';
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    const offset = Math.floor(bufferLength / 4);
                    for (let i = 0; i < bufferLength - offset; i++) {
                        const x = ((timeData[i] - 128) / 128) * scale + centerX;
                        const y = ((timeData[i + offset] - 128) / 128) * scale + centerY;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }

                    ctx.stroke();
                };

                const draw = () => {
                    if (!synth.visualizerEnabled) return;

                    requestAnimationFrame(draw);

                    switch (synth.visualizerMode) {
                        case 'lissajous':
                            drawLissajous();
                            break;
                        case 'oscilloscope':
                        default:
                            drawOscilloscope();
                            break;
                    }
                };

                draw();
            },

            toggleVisualizer() {
                this.visualizerEnabled = !this.visualizerEnabled;
                const visualizer = document.getElementById('visualizer');

                if (this.visualizerEnabled) {
                    visualizer.style.display = 'block';
                    this.updateVisualizer();
                } else {
                    visualizer.style.display = 'none';
                }
            },

            animatePlayback() {
                const startTime = this.audioContext.currentTime;
                let lastUpdateTime = 0;
                const updateInterval = 50; // Update every 50ms

                const animate = () => {
                    if (!this.playbackAudio || this.playbackAudio.paused) {
                        document.querySelectorAll('.key.active').forEach(key => key.classList.remove('active'));
                        return;
                    }

                    const currentTime = this.audioContext.currentTime - startTime;

                    if (currentTime - lastUpdateTime >= updateInterval / 1000) {
                        this.recordedNotes.forEach(noteEvent => {
                            if (Math.abs(noteEvent.time - currentTime) < 0.05) {
                                const keyElement = document.querySelector(`.key[data-note="${noteEvent.note}"]`);
                                if (keyElement) {
                                    if (noteEvent.isNoteOn) {
                                        keyElement.classList.add('active');
                                    } else {
                                        keyElement.classList.remove('active');
                                    }
                                }
                            }
                        });

                        lastUpdateTime = currentTime;
                    }

                    requestAnimationFrame(animate);
                };

                requestAnimationFrame(animate);
            },

            saveRecording() {
                if (this.recordedChunks.length === 0) {
                    console.log('No recording to save');
                    return;
                }

                const blob = new Blob(this.recordedChunks, { type: 'audio/wav' });
                const reader = new FileReader();
                reader.onload = (event) => {
                    const audioData = event.target.result;
                    const presets = this.getPresets();
                    const data = {
                        audio: audioData,
                        presets: presets,
                        notes: this.recordedNotes
                    };
                    const json = JSON.stringify(data);
                    const jsonBlob = new Blob([json], { type: 'application/json' });

                    const saveFile = async () => {
                        try {
                            const handle = await window.showSaveFilePicker({
                                suggestedName: 'browsynth_recording.json',
                                types: [{
                                    description: 'Browsynth Recording',
                                    accept: { 'application/json': ['.json'] },
                                }],
                            });
                            const writable = await handle.createWritable();
                            await writable.write(jsonBlob);
                            await writable.close();
                            console.log('File saved successfully');
                        } catch (err) {
                            console.error('Failed to save file:', err);
                        }
                    };

                    saveFile();
                };
                reader.readAsDataURL(blob);
            },

            loadRecording() {
                const loadFile = async () => {
                    try {
                        const [handle] = await window.showOpenFilePicker({
                            types: [{
                                description: 'Browsynth Recording',
                                accept: { 'application/json': ['.json'] },
                            }],
                        });
                        const file = await handle.getFile();
                        const contents = await file.text();
                        const data = JSON.parse(contents);
                        this.setPresets(data.presets);

                        if (this.playbackAudio) {
                            this.playbackAudio.pause();
                            this.playbackAudio.currentTime = 0;
                        }
                        this.playbackAudio = new Audio(data.audio);
                        this.recordedChunks = [];
                        this.recordedNotes = data.notes || [];
                        fetch(data.audio)
                            .then(res => res.blob())
                            .then(blob => {
                                this.recordedChunks.push(blob);
                            });
                        document.getElementById('playButton').disabled = false;
                        document.getElementById('saveButton').disabled = false;
                        console.log('File loaded successfully');
                    } catch (err) {
                        console.error('Failed to load file:', err);
                    }
                };

                loadFile();
            },

            getPresets() {
                const presets = {};
                for (const [key, control] of Object.entries(SynthState.controls)) {
                    presets[key] = control.type === 'checkbox' ? control.checked : control.value;
                }
                return presets;
            },

            setPresets(presets) {
                for (const [key, value] of Object.entries(presets)) {
                    const control = SynthState.controls[key];
                    if (control) {
                        if (control.type === 'checkbox') {
                            control.checked = value;
                        } else {
                            control.value = value;
                        }
                        this.updateParams(key);
                    }
                }
            },

            createMediaStreamFromAudioGraph() {
                const dest = this.audioContext.createMediaStreamDestination();
                this.analyser.connect(dest);
                return dest.stream;
            },

            recordNoteEvent(note, isNoteOn) {
                if (this.recorder && this.recorder.state === "recording") {
                    const time = this.audioContext.currentTime - this.recordingStartTime;
                    this.recordedNotes.push({ note, time, isNoteOn });
                }
            },

            exportWav() {
                if (!this.audioContext) {
                    console.error('AudioContext is not initialized');
                    return;
                }
                if (this.recordedChunks.length === 0) {
                    console.log('No recording to export');
                    return;
                }

                const blob = new Blob(this.recordedChunks, { type: 'audio/wav' });

                blob.arrayBuffer().then(arrayBuffer => {
                    this.audioContext.decodeAudioData(arrayBuffer, (audioBuffer) => {
                        const offlineCtx = new OfflineAudioContext(audioBuffer.numberOfChannels, audioBuffer.length, 44100);
                        const source = offlineCtx.createBufferSource();
                        source.buffer = audioBuffer;
                        source.connect(offlineCtx.destination);
                        source.start();

                        offlineCtx.startRendering().then(renderedBuffer => {
                            const wav = this.audioBufferToWav(renderedBuffer);
                            const wavBlob = new Blob([new DataView(wav)], { type: 'audio/wav' });

                            const url = URL.createObjectURL(wavBlob);
                            const a = document.createElement('a');
                            document.body.appendChild(a);
                            a.style = 'display: none';
                            a.href = url;
                            a.download = 'browsynth_recording.wav';
                            a.click();
                            window.URL.revokeObjectURL(url);
                        }).catch(err => {
                            console.error('Error rendering audio:', err);
                        });
                    }, (err) => {
                        console.error('Error decoding audio data:', err);
                    });
                }).catch(err => {
                    console.error('Error reading blob:', err);
                });
            },

            audioBufferToWav(buffer) {
                const numChannels = buffer.numberOfChannels;
                const sampleRate = 44100;
                const format = 1; // PCM
                const bitDepth = 24;

                let result = new ArrayBuffer(44 + buffer.length * numChannels * 3);
                let view = new DataView(result);

                // Write WAV header
                this.writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + buffer.length * numChannels * 3, true);
                this.writeString(view, 8, 'WAVE');
                this.writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, format, true);
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * numChannels * 3, true);
                view.setUint16(32, numChannels * 3, true);
                view.setUint16(34, bitDepth, true);
                this.writeString(view, 36, 'data');
                view.setUint32(40, buffer.length * numChannels * 3, true);

                // Write audio data
                const length = buffer.length;
                let offset = 44;
                for (let i = 0; i < length; i++) {
                    for (let channel = 0; channel < numChannels; channel++) {
                        let sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        sample = sample < 0 ? sample * 0x7FFFFF : sample * 0x7FFFFF;
                        view.setInt24(offset, sample, true);
                        offset += 3;
                    }
                }

                return result;
            },

            writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            },
        };

        DataView.prototype.setInt24 = function (pos, val, littleEndian) {
            this.setUint8(pos + (littleEndian ? 0 : 2), val & 0xFF);
            this.setUint8(pos + 1, (val >> 8) & 0xFF);
            this.setUint8(pos + (littleEndian ? 2 : 0), (val >> 16) & 0xFF);
        };

        // Initialize the synth when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => Synth.initialize());
    </script>
</body>

</html>